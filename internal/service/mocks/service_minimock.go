// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/avito-shop/internal/service.Service -o service_minimock.go -n ServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	sm "github.com/wDRxxx/avito-shop/internal/service/models"
)

// ServiceMock implements mm_service.Service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBuyItem          func(ctx context.Context, userID int, title string) (err error)
	funcBuyItemOrigin    string
	inspectFuncBuyItem   func(ctx context.Context, userID int, title string)
	afterBuyItemCounter  uint64
	beforeBuyItemCounter uint64
	BuyItemMock          mServiceMockBuyItem

	funcSendCoin          func(ctx context.Context, toUser string, fromUserID int, amount int) (err error)
	funcSendCoinOrigin    string
	inspectFuncSendCoin   func(ctx context.Context, toUser string, fromUserID int, amount int)
	afterSendCoinCounter  uint64
	beforeSendCoinCounter uint64
	SendCoinMock          mServiceMockSendCoin

	funcUserInfo          func(ctx context.Context, userID int) (up1 *sm.UserInfo, err error)
	funcUserInfoOrigin    string
	inspectFuncUserInfo   func(ctx context.Context, userID int)
	afterUserInfoCounter  uint64
	beforeUserInfoCounter uint64
	UserInfoMock          mServiceMockUserInfo

	funcUserToken          func(ctx context.Context, username string, password string) (s1 string, err error)
	funcUserTokenOrigin    string
	inspectFuncUserToken   func(ctx context.Context, username string, password string)
	afterUserTokenCounter  uint64
	beforeUserTokenCounter uint64
	UserTokenMock          mServiceMockUserToken
}

// NewServiceMock returns a mock for mm_service.Service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuyItemMock = mServiceMockBuyItem{mock: m}
	m.BuyItemMock.callArgs = []*ServiceMockBuyItemParams{}

	m.SendCoinMock = mServiceMockSendCoin{mock: m}
	m.SendCoinMock.callArgs = []*ServiceMockSendCoinParams{}

	m.UserInfoMock = mServiceMockUserInfo{mock: m}
	m.UserInfoMock.callArgs = []*ServiceMockUserInfoParams{}

	m.UserTokenMock = mServiceMockUserToken{mock: m}
	m.UserTokenMock.callArgs = []*ServiceMockUserTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockBuyItem struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockBuyItemExpectation
	expectations       []*ServiceMockBuyItemExpectation

	callArgs []*ServiceMockBuyItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockBuyItemExpectation specifies expectation struct of the Service.BuyItem
type ServiceMockBuyItemExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockBuyItemParams
	paramPtrs          *ServiceMockBuyItemParamPtrs
	expectationOrigins ServiceMockBuyItemExpectationOrigins
	results            *ServiceMockBuyItemResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockBuyItemParams contains parameters of the Service.BuyItem
type ServiceMockBuyItemParams struct {
	ctx    context.Context
	userID int
	title  string
}

// ServiceMockBuyItemParamPtrs contains pointers to parameters of the Service.BuyItem
type ServiceMockBuyItemParamPtrs struct {
	ctx    *context.Context
	userID *int
	title  *string
}

// ServiceMockBuyItemResults contains results of the Service.BuyItem
type ServiceMockBuyItemResults struct {
	err error
}

// ServiceMockBuyItemOrigins contains origins of expectations of the Service.BuyItem
type ServiceMockBuyItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originTitle  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBuyItem *mServiceMockBuyItem) Optional() *mServiceMockBuyItem {
	mmBuyItem.optional = true
	return mmBuyItem
}

// Expect sets up expected params for Service.BuyItem
func (mmBuyItem *mServiceMockBuyItem) Expect(ctx context.Context, userID int, title string) *mServiceMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &ServiceMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.paramPtrs != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by ExpectParams functions")
	}

	mmBuyItem.defaultExpectation.params = &ServiceMockBuyItemParams{ctx, userID, title}
	mmBuyItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBuyItem.expectations {
		if minimock.Equal(e.params, mmBuyItem.defaultExpectation.params) {
			mmBuyItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuyItem.defaultExpectation.params)
		}
	}

	return mmBuyItem
}

// ExpectCtxParam1 sets up expected param ctx for Service.BuyItem
func (mmBuyItem *mServiceMockBuyItem) ExpectCtxParam1(ctx context.Context) *mServiceMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &ServiceMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &ServiceMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmBuyItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBuyItem
}

// ExpectUserIDParam2 sets up expected param userID for Service.BuyItem
func (mmBuyItem *mServiceMockBuyItem) ExpectUserIDParam2(userID int) *mServiceMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &ServiceMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &ServiceMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.userID = &userID
	mmBuyItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmBuyItem
}

// ExpectTitleParam3 sets up expected param title for Service.BuyItem
func (mmBuyItem *mServiceMockBuyItem) ExpectTitleParam3(title string) *mServiceMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &ServiceMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &ServiceMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.title = &title
	mmBuyItem.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmBuyItem
}

// Inspect accepts an inspector function that has same arguments as the Service.BuyItem
func (mmBuyItem *mServiceMockBuyItem) Inspect(f func(ctx context.Context, userID int, title string)) *mServiceMockBuyItem {
	if mmBuyItem.mock.inspectFuncBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("Inspect function is already set for ServiceMock.BuyItem")
	}

	mmBuyItem.mock.inspectFuncBuyItem = f

	return mmBuyItem
}

// Return sets up results that will be returned by Service.BuyItem
func (mmBuyItem *mServiceMockBuyItem) Return(err error) *ServiceMock {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &ServiceMockBuyItemExpectation{mock: mmBuyItem.mock}
	}
	mmBuyItem.defaultExpectation.results = &ServiceMockBuyItemResults{err}
	mmBuyItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBuyItem.mock
}

// Set uses given function f to mock the Service.BuyItem method
func (mmBuyItem *mServiceMockBuyItem) Set(f func(ctx context.Context, userID int, title string) (err error)) *ServiceMock {
	if mmBuyItem.defaultExpectation != nil {
		mmBuyItem.mock.t.Fatalf("Default expectation is already set for the Service.BuyItem method")
	}

	if len(mmBuyItem.expectations) > 0 {
		mmBuyItem.mock.t.Fatalf("Some expectations are already set for the Service.BuyItem method")
	}

	mmBuyItem.mock.funcBuyItem = f
	mmBuyItem.mock.funcBuyItemOrigin = minimock.CallerInfo(1)
	return mmBuyItem.mock
}

// When sets expectation for the Service.BuyItem which will trigger the result defined by the following
// Then helper
func (mmBuyItem *mServiceMockBuyItem) When(ctx context.Context, userID int, title string) *ServiceMockBuyItemExpectation {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("ServiceMock.BuyItem mock is already set by Set")
	}

	expectation := &ServiceMockBuyItemExpectation{
		mock:               mmBuyItem.mock,
		params:             &ServiceMockBuyItemParams{ctx, userID, title},
		expectationOrigins: ServiceMockBuyItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBuyItem.expectations = append(mmBuyItem.expectations, expectation)
	return expectation
}

// Then sets up Service.BuyItem return parameters for the expectation previously defined by the When method
func (e *ServiceMockBuyItemExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockBuyItemResults{err}
	return e.mock
}

// Times sets number of times Service.BuyItem should be invoked
func (mmBuyItem *mServiceMockBuyItem) Times(n uint64) *mServiceMockBuyItem {
	if n == 0 {
		mmBuyItem.mock.t.Fatalf("Times of ServiceMock.BuyItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBuyItem.expectedInvocations, n)
	mmBuyItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBuyItem
}

func (mmBuyItem *mServiceMockBuyItem) invocationsDone() bool {
	if len(mmBuyItem.expectations) == 0 && mmBuyItem.defaultExpectation == nil && mmBuyItem.mock.funcBuyItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBuyItem.mock.afterBuyItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBuyItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BuyItem implements mm_service.Service
func (mmBuyItem *ServiceMock) BuyItem(ctx context.Context, userID int, title string) (err error) {
	mm_atomic.AddUint64(&mmBuyItem.beforeBuyItemCounter, 1)
	defer mm_atomic.AddUint64(&mmBuyItem.afterBuyItemCounter, 1)

	mmBuyItem.t.Helper()

	if mmBuyItem.inspectFuncBuyItem != nil {
		mmBuyItem.inspectFuncBuyItem(ctx, userID, title)
	}

	mm_params := ServiceMockBuyItemParams{ctx, userID, title}

	// Record call args
	mmBuyItem.BuyItemMock.mutex.Lock()
	mmBuyItem.BuyItemMock.callArgs = append(mmBuyItem.BuyItemMock.callArgs, &mm_params)
	mmBuyItem.BuyItemMock.mutex.Unlock()

	for _, e := range mmBuyItem.BuyItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBuyItem.BuyItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuyItem.BuyItemMock.defaultExpectation.Counter, 1)
		mm_want := mmBuyItem.BuyItemMock.defaultExpectation.params
		mm_want_ptrs := mmBuyItem.BuyItemMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockBuyItemParams{ctx, userID, title}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBuyItem.t.Errorf("ServiceMock.BuyItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmBuyItem.t.Errorf("ServiceMock.BuyItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmBuyItem.t.Errorf("ServiceMock.BuyItem got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuyItem.t.Errorf("ServiceMock.BuyItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuyItem.BuyItemMock.defaultExpectation.results
		if mm_results == nil {
			mmBuyItem.t.Fatal("No results are set for the ServiceMock.BuyItem")
		}
		return (*mm_results).err
	}
	if mmBuyItem.funcBuyItem != nil {
		return mmBuyItem.funcBuyItem(ctx, userID, title)
	}
	mmBuyItem.t.Fatalf("Unexpected call to ServiceMock.BuyItem. %v %v %v", ctx, userID, title)
	return
}

// BuyItemAfterCounter returns a count of finished ServiceMock.BuyItem invocations
func (mmBuyItem *ServiceMock) BuyItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyItem.afterBuyItemCounter)
}

// BuyItemBeforeCounter returns a count of ServiceMock.BuyItem invocations
func (mmBuyItem *ServiceMock) BuyItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyItem.beforeBuyItemCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.BuyItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuyItem *mServiceMockBuyItem) Calls() []*ServiceMockBuyItemParams {
	mmBuyItem.mutex.RLock()

	argCopy := make([]*ServiceMockBuyItemParams, len(mmBuyItem.callArgs))
	copy(argCopy, mmBuyItem.callArgs)

	mmBuyItem.mutex.RUnlock()

	return argCopy
}

// MinimockBuyItemDone returns true if the count of the BuyItem invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockBuyItemDone() bool {
	if m.BuyItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BuyItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BuyItemMock.invocationsDone()
}

// MinimockBuyItemInspect logs each unmet expectation
func (m *ServiceMock) MinimockBuyItemInspect() {
	for _, e := range m.BuyItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.BuyItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBuyItemCounter := mm_atomic.LoadUint64(&m.afterBuyItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BuyItemMock.defaultExpectation != nil && afterBuyItemCounter < 1 {
		if m.BuyItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.BuyItem at\n%s", m.BuyItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.BuyItem at\n%s with params: %#v", m.BuyItemMock.defaultExpectation.expectationOrigins.origin, *m.BuyItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuyItem != nil && afterBuyItemCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.BuyItem at\n%s", m.funcBuyItemOrigin)
	}

	if !m.BuyItemMock.invocationsDone() && afterBuyItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.BuyItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BuyItemMock.expectedInvocations), m.BuyItemMock.expectedInvocationsOrigin, afterBuyItemCounter)
	}
}

type mServiceMockSendCoin struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockSendCoinExpectation
	expectations       []*ServiceMockSendCoinExpectation

	callArgs []*ServiceMockSendCoinParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockSendCoinExpectation specifies expectation struct of the Service.SendCoin
type ServiceMockSendCoinExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockSendCoinParams
	paramPtrs          *ServiceMockSendCoinParamPtrs
	expectationOrigins ServiceMockSendCoinExpectationOrigins
	results            *ServiceMockSendCoinResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockSendCoinParams contains parameters of the Service.SendCoin
type ServiceMockSendCoinParams struct {
	ctx        context.Context
	toUser     string
	fromUserID int
	amount     int
}

// ServiceMockSendCoinParamPtrs contains pointers to parameters of the Service.SendCoin
type ServiceMockSendCoinParamPtrs struct {
	ctx        *context.Context
	toUser     *string
	fromUserID *int
	amount     *int
}

// ServiceMockSendCoinResults contains results of the Service.SendCoin
type ServiceMockSendCoinResults struct {
	err error
}

// ServiceMockSendCoinOrigins contains origins of expectations of the Service.SendCoin
type ServiceMockSendCoinExpectationOrigins struct {
	origin           string
	originCtx        string
	originToUser     string
	originFromUserID string
	originAmount     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendCoin *mServiceMockSendCoin) Optional() *mServiceMockSendCoin {
	mmSendCoin.optional = true
	return mmSendCoin
}

// Expect sets up expected params for Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) Expect(ctx context.Context, toUser string, fromUserID int, amount int) *mServiceMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &ServiceMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.paramPtrs != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by ExpectParams functions")
	}

	mmSendCoin.defaultExpectation.params = &ServiceMockSendCoinParams{ctx, toUser, fromUserID, amount}
	mmSendCoin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendCoin.expectations {
		if minimock.Equal(e.params, mmSendCoin.defaultExpectation.params) {
			mmSendCoin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendCoin.defaultExpectation.params)
		}
	}

	return mmSendCoin
}

// ExpectCtxParam1 sets up expected param ctx for Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) ExpectCtxParam1(ctx context.Context) *mServiceMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &ServiceMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &ServiceMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendCoin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendCoin
}

// ExpectToUserParam2 sets up expected param toUser for Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) ExpectToUserParam2(toUser string) *mServiceMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &ServiceMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &ServiceMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.toUser = &toUser
	mmSendCoin.defaultExpectation.expectationOrigins.originToUser = minimock.CallerInfo(1)

	return mmSendCoin
}

// ExpectFromUserIDParam3 sets up expected param fromUserID for Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) ExpectFromUserIDParam3(fromUserID int) *mServiceMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &ServiceMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &ServiceMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.fromUserID = &fromUserID
	mmSendCoin.defaultExpectation.expectationOrigins.originFromUserID = minimock.CallerInfo(1)

	return mmSendCoin
}

// ExpectAmountParam4 sets up expected param amount for Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) ExpectAmountParam4(amount int) *mServiceMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &ServiceMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &ServiceMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.amount = &amount
	mmSendCoin.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmSendCoin
}

// Inspect accepts an inspector function that has same arguments as the Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) Inspect(f func(ctx context.Context, toUser string, fromUserID int, amount int)) *mServiceMockSendCoin {
	if mmSendCoin.mock.inspectFuncSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("Inspect function is already set for ServiceMock.SendCoin")
	}

	mmSendCoin.mock.inspectFuncSendCoin = f

	return mmSendCoin
}

// Return sets up results that will be returned by Service.SendCoin
func (mmSendCoin *mServiceMockSendCoin) Return(err error) *ServiceMock {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &ServiceMockSendCoinExpectation{mock: mmSendCoin.mock}
	}
	mmSendCoin.defaultExpectation.results = &ServiceMockSendCoinResults{err}
	mmSendCoin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendCoin.mock
}

// Set uses given function f to mock the Service.SendCoin method
func (mmSendCoin *mServiceMockSendCoin) Set(f func(ctx context.Context, toUser string, fromUserID int, amount int) (err error)) *ServiceMock {
	if mmSendCoin.defaultExpectation != nil {
		mmSendCoin.mock.t.Fatalf("Default expectation is already set for the Service.SendCoin method")
	}

	if len(mmSendCoin.expectations) > 0 {
		mmSendCoin.mock.t.Fatalf("Some expectations are already set for the Service.SendCoin method")
	}

	mmSendCoin.mock.funcSendCoin = f
	mmSendCoin.mock.funcSendCoinOrigin = minimock.CallerInfo(1)
	return mmSendCoin.mock
}

// When sets expectation for the Service.SendCoin which will trigger the result defined by the following
// Then helper
func (mmSendCoin *mServiceMockSendCoin) When(ctx context.Context, toUser string, fromUserID int, amount int) *ServiceMockSendCoinExpectation {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("ServiceMock.SendCoin mock is already set by Set")
	}

	expectation := &ServiceMockSendCoinExpectation{
		mock:               mmSendCoin.mock,
		params:             &ServiceMockSendCoinParams{ctx, toUser, fromUserID, amount},
		expectationOrigins: ServiceMockSendCoinExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendCoin.expectations = append(mmSendCoin.expectations, expectation)
	return expectation
}

// Then sets up Service.SendCoin return parameters for the expectation previously defined by the When method
func (e *ServiceMockSendCoinExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockSendCoinResults{err}
	return e.mock
}

// Times sets number of times Service.SendCoin should be invoked
func (mmSendCoin *mServiceMockSendCoin) Times(n uint64) *mServiceMockSendCoin {
	if n == 0 {
		mmSendCoin.mock.t.Fatalf("Times of ServiceMock.SendCoin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendCoin.expectedInvocations, n)
	mmSendCoin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendCoin
}

func (mmSendCoin *mServiceMockSendCoin) invocationsDone() bool {
	if len(mmSendCoin.expectations) == 0 && mmSendCoin.defaultExpectation == nil && mmSendCoin.mock.funcSendCoin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendCoin.mock.afterSendCoinCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendCoin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendCoin implements mm_service.Service
func (mmSendCoin *ServiceMock) SendCoin(ctx context.Context, toUser string, fromUserID int, amount int) (err error) {
	mm_atomic.AddUint64(&mmSendCoin.beforeSendCoinCounter, 1)
	defer mm_atomic.AddUint64(&mmSendCoin.afterSendCoinCounter, 1)

	mmSendCoin.t.Helper()

	if mmSendCoin.inspectFuncSendCoin != nil {
		mmSendCoin.inspectFuncSendCoin(ctx, toUser, fromUserID, amount)
	}

	mm_params := ServiceMockSendCoinParams{ctx, toUser, fromUserID, amount}

	// Record call args
	mmSendCoin.SendCoinMock.mutex.Lock()
	mmSendCoin.SendCoinMock.callArgs = append(mmSendCoin.SendCoinMock.callArgs, &mm_params)
	mmSendCoin.SendCoinMock.mutex.Unlock()

	for _, e := range mmSendCoin.SendCoinMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendCoin.SendCoinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendCoin.SendCoinMock.defaultExpectation.Counter, 1)
		mm_want := mmSendCoin.SendCoinMock.defaultExpectation.params
		mm_want_ptrs := mmSendCoin.SendCoinMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockSendCoinParams{ctx, toUser, fromUserID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendCoin.t.Errorf("ServiceMock.SendCoin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.toUser != nil && !minimock.Equal(*mm_want_ptrs.toUser, mm_got.toUser) {
				mmSendCoin.t.Errorf("ServiceMock.SendCoin got unexpected parameter toUser, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originToUser, *mm_want_ptrs.toUser, mm_got.toUser, minimock.Diff(*mm_want_ptrs.toUser, mm_got.toUser))
			}

			if mm_want_ptrs.fromUserID != nil && !minimock.Equal(*mm_want_ptrs.fromUserID, mm_got.fromUserID) {
				mmSendCoin.t.Errorf("ServiceMock.SendCoin got unexpected parameter fromUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originFromUserID, *mm_want_ptrs.fromUserID, mm_got.fromUserID, minimock.Diff(*mm_want_ptrs.fromUserID, mm_got.fromUserID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmSendCoin.t.Errorf("ServiceMock.SendCoin got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendCoin.t.Errorf("ServiceMock.SendCoin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendCoin.SendCoinMock.defaultExpectation.results
		if mm_results == nil {
			mmSendCoin.t.Fatal("No results are set for the ServiceMock.SendCoin")
		}
		return (*mm_results).err
	}
	if mmSendCoin.funcSendCoin != nil {
		return mmSendCoin.funcSendCoin(ctx, toUser, fromUserID, amount)
	}
	mmSendCoin.t.Fatalf("Unexpected call to ServiceMock.SendCoin. %v %v %v %v", ctx, toUser, fromUserID, amount)
	return
}

// SendCoinAfterCounter returns a count of finished ServiceMock.SendCoin invocations
func (mmSendCoin *ServiceMock) SendCoinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCoin.afterSendCoinCounter)
}

// SendCoinBeforeCounter returns a count of ServiceMock.SendCoin invocations
func (mmSendCoin *ServiceMock) SendCoinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCoin.beforeSendCoinCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.SendCoin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendCoin *mServiceMockSendCoin) Calls() []*ServiceMockSendCoinParams {
	mmSendCoin.mutex.RLock()

	argCopy := make([]*ServiceMockSendCoinParams, len(mmSendCoin.callArgs))
	copy(argCopy, mmSendCoin.callArgs)

	mmSendCoin.mutex.RUnlock()

	return argCopy
}

// MinimockSendCoinDone returns true if the count of the SendCoin invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockSendCoinDone() bool {
	if m.SendCoinMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendCoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendCoinMock.invocationsDone()
}

// MinimockSendCoinInspect logs each unmet expectation
func (m *ServiceMock) MinimockSendCoinInspect() {
	for _, e := range m.SendCoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.SendCoin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCoinCounter := mm_atomic.LoadUint64(&m.afterSendCoinCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendCoinMock.defaultExpectation != nil && afterSendCoinCounter < 1 {
		if m.SendCoinMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.SendCoin at\n%s", m.SendCoinMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.SendCoin at\n%s with params: %#v", m.SendCoinMock.defaultExpectation.expectationOrigins.origin, *m.SendCoinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCoin != nil && afterSendCoinCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.SendCoin at\n%s", m.funcSendCoinOrigin)
	}

	if !m.SendCoinMock.invocationsDone() && afterSendCoinCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.SendCoin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendCoinMock.expectedInvocations), m.SendCoinMock.expectedInvocationsOrigin, afterSendCoinCounter)
	}
}

type mServiceMockUserInfo struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUserInfoExpectation
	expectations       []*ServiceMockUserInfoExpectation

	callArgs []*ServiceMockUserInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUserInfoExpectation specifies expectation struct of the Service.UserInfo
type ServiceMockUserInfoExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUserInfoParams
	paramPtrs          *ServiceMockUserInfoParamPtrs
	expectationOrigins ServiceMockUserInfoExpectationOrigins
	results            *ServiceMockUserInfoResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUserInfoParams contains parameters of the Service.UserInfo
type ServiceMockUserInfoParams struct {
	ctx    context.Context
	userID int
}

// ServiceMockUserInfoParamPtrs contains pointers to parameters of the Service.UserInfo
type ServiceMockUserInfoParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// ServiceMockUserInfoResults contains results of the Service.UserInfo
type ServiceMockUserInfoResults struct {
	up1 *sm.UserInfo
	err error
}

// ServiceMockUserInfoOrigins contains origins of expectations of the Service.UserInfo
type ServiceMockUserInfoExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserInfo *mServiceMockUserInfo) Optional() *mServiceMockUserInfo {
	mmUserInfo.optional = true
	return mmUserInfo
}

// Expect sets up expected params for Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) Expect(ctx context.Context, userID int) *mServiceMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.paramPtrs != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by ExpectParams functions")
	}

	mmUserInfo.defaultExpectation.params = &ServiceMockUserInfoParams{ctx, userID}
	mmUserInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserInfo.expectations {
		if minimock.Equal(e.params, mmUserInfo.defaultExpectation.params) {
			mmUserInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserInfo.defaultExpectation.params)
		}
	}

	return mmUserInfo
}

// ExpectCtxParam1 sets up expected param ctx for Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) ExpectCtxParam1(ctx context.Context) *mServiceMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.params != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Expect")
	}

	if mmUserInfo.defaultExpectation.paramPtrs == nil {
		mmUserInfo.defaultExpectation.paramPtrs = &ServiceMockUserInfoParamPtrs{}
	}
	mmUserInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserInfo
}

// ExpectUserIDParam2 sets up expected param userID for Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) ExpectUserIDParam2(userID int) *mServiceMockUserInfo {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{}
	}

	if mmUserInfo.defaultExpectation.params != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Expect")
	}

	if mmUserInfo.defaultExpectation.paramPtrs == nil {
		mmUserInfo.defaultExpectation.paramPtrs = &ServiceMockUserInfoParamPtrs{}
	}
	mmUserInfo.defaultExpectation.paramPtrs.userID = &userID
	mmUserInfo.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserInfo
}

// Inspect accepts an inspector function that has same arguments as the Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) Inspect(f func(ctx context.Context, userID int)) *mServiceMockUserInfo {
	if mmUserInfo.mock.inspectFuncUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("Inspect function is already set for ServiceMock.UserInfo")
	}

	mmUserInfo.mock.inspectFuncUserInfo = f

	return mmUserInfo
}

// Return sets up results that will be returned by Service.UserInfo
func (mmUserInfo *mServiceMockUserInfo) Return(up1 *sm.UserInfo, err error) *ServiceMock {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	if mmUserInfo.defaultExpectation == nil {
		mmUserInfo.defaultExpectation = &ServiceMockUserInfoExpectation{mock: mmUserInfo.mock}
	}
	mmUserInfo.defaultExpectation.results = &ServiceMockUserInfoResults{up1, err}
	mmUserInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserInfo.mock
}

// Set uses given function f to mock the Service.UserInfo method
func (mmUserInfo *mServiceMockUserInfo) Set(f func(ctx context.Context, userID int) (up1 *sm.UserInfo, err error)) *ServiceMock {
	if mmUserInfo.defaultExpectation != nil {
		mmUserInfo.mock.t.Fatalf("Default expectation is already set for the Service.UserInfo method")
	}

	if len(mmUserInfo.expectations) > 0 {
		mmUserInfo.mock.t.Fatalf("Some expectations are already set for the Service.UserInfo method")
	}

	mmUserInfo.mock.funcUserInfo = f
	mmUserInfo.mock.funcUserInfoOrigin = minimock.CallerInfo(1)
	return mmUserInfo.mock
}

// When sets expectation for the Service.UserInfo which will trigger the result defined by the following
// Then helper
func (mmUserInfo *mServiceMockUserInfo) When(ctx context.Context, userID int) *ServiceMockUserInfoExpectation {
	if mmUserInfo.mock.funcUserInfo != nil {
		mmUserInfo.mock.t.Fatalf("ServiceMock.UserInfo mock is already set by Set")
	}

	expectation := &ServiceMockUserInfoExpectation{
		mock:               mmUserInfo.mock,
		params:             &ServiceMockUserInfoParams{ctx, userID},
		expectationOrigins: ServiceMockUserInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserInfo.expectations = append(mmUserInfo.expectations, expectation)
	return expectation
}

// Then sets up Service.UserInfo return parameters for the expectation previously defined by the When method
func (e *ServiceMockUserInfoExpectation) Then(up1 *sm.UserInfo, err error) *ServiceMock {
	e.results = &ServiceMockUserInfoResults{up1, err}
	return e.mock
}

// Times sets number of times Service.UserInfo should be invoked
func (mmUserInfo *mServiceMockUserInfo) Times(n uint64) *mServiceMockUserInfo {
	if n == 0 {
		mmUserInfo.mock.t.Fatalf("Times of ServiceMock.UserInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserInfo.expectedInvocations, n)
	mmUserInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserInfo
}

func (mmUserInfo *mServiceMockUserInfo) invocationsDone() bool {
	if len(mmUserInfo.expectations) == 0 && mmUserInfo.defaultExpectation == nil && mmUserInfo.mock.funcUserInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserInfo.mock.afterUserInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserInfo implements mm_service.Service
func (mmUserInfo *ServiceMock) UserInfo(ctx context.Context, userID int) (up1 *sm.UserInfo, err error) {
	mm_atomic.AddUint64(&mmUserInfo.beforeUserInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmUserInfo.afterUserInfoCounter, 1)

	mmUserInfo.t.Helper()

	if mmUserInfo.inspectFuncUserInfo != nil {
		mmUserInfo.inspectFuncUserInfo(ctx, userID)
	}

	mm_params := ServiceMockUserInfoParams{ctx, userID}

	// Record call args
	mmUserInfo.UserInfoMock.mutex.Lock()
	mmUserInfo.UserInfoMock.callArgs = append(mmUserInfo.UserInfoMock.callArgs, &mm_params)
	mmUserInfo.UserInfoMock.mutex.Unlock()

	for _, e := range mmUserInfo.UserInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUserInfo.UserInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserInfo.UserInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmUserInfo.UserInfoMock.defaultExpectation.params
		mm_want_ptrs := mmUserInfo.UserInfoMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUserInfoParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserInfo.t.Errorf("ServiceMock.UserInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserInfo.t.Errorf("ServiceMock.UserInfo got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserInfo.t.Errorf("ServiceMock.UserInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserInfo.UserInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserInfo.UserInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmUserInfo.t.Fatal("No results are set for the ServiceMock.UserInfo")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUserInfo.funcUserInfo != nil {
		return mmUserInfo.funcUserInfo(ctx, userID)
	}
	mmUserInfo.t.Fatalf("Unexpected call to ServiceMock.UserInfo. %v %v", ctx, userID)
	return
}

// UserInfoAfterCounter returns a count of finished ServiceMock.UserInfo invocations
func (mmUserInfo *ServiceMock) UserInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInfo.afterUserInfoCounter)
}

// UserInfoBeforeCounter returns a count of ServiceMock.UserInfo invocations
func (mmUserInfo *ServiceMock) UserInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInfo.beforeUserInfoCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UserInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserInfo *mServiceMockUserInfo) Calls() []*ServiceMockUserInfoParams {
	mmUserInfo.mutex.RLock()

	argCopy := make([]*ServiceMockUserInfoParams, len(mmUserInfo.callArgs))
	copy(argCopy, mmUserInfo.callArgs)

	mmUserInfo.mutex.RUnlock()

	return argCopy
}

// MinimockUserInfoDone returns true if the count of the UserInfo invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUserInfoDone() bool {
	if m.UserInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserInfoMock.invocationsDone()
}

// MinimockUserInfoInspect logs each unmet expectation
func (m *ServiceMock) MinimockUserInfoInspect() {
	for _, e := range m.UserInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserInfoCounter := mm_atomic.LoadUint64(&m.afterUserInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserInfoMock.defaultExpectation != nil && afterUserInfoCounter < 1 {
		if m.UserInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s", m.UserInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s with params: %#v", m.UserInfoMock.defaultExpectation.expectationOrigins.origin, *m.UserInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserInfo != nil && afterUserInfoCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.UserInfo at\n%s", m.funcUserInfoOrigin)
	}

	if !m.UserInfoMock.invocationsDone() && afterUserInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.UserInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserInfoMock.expectedInvocations), m.UserInfoMock.expectedInvocationsOrigin, afterUserInfoCounter)
	}
}

type mServiceMockUserToken struct {
	optional           bool
	mock               *ServiceMock
	defaultExpectation *ServiceMockUserTokenExpectation
	expectations       []*ServiceMockUserTokenExpectation

	callArgs []*ServiceMockUserTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceMockUserTokenExpectation specifies expectation struct of the Service.UserToken
type ServiceMockUserTokenExpectation struct {
	mock               *ServiceMock
	params             *ServiceMockUserTokenParams
	paramPtrs          *ServiceMockUserTokenParamPtrs
	expectationOrigins ServiceMockUserTokenExpectationOrigins
	results            *ServiceMockUserTokenResults
	returnOrigin       string
	Counter            uint64
}

// ServiceMockUserTokenParams contains parameters of the Service.UserToken
type ServiceMockUserTokenParams struct {
	ctx      context.Context
	username string
	password string
}

// ServiceMockUserTokenParamPtrs contains pointers to parameters of the Service.UserToken
type ServiceMockUserTokenParamPtrs struct {
	ctx      *context.Context
	username *string
	password *string
}

// ServiceMockUserTokenResults contains results of the Service.UserToken
type ServiceMockUserTokenResults struct {
	s1  string
	err error
}

// ServiceMockUserTokenOrigins contains origins of expectations of the Service.UserToken
type ServiceMockUserTokenExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserToken *mServiceMockUserToken) Optional() *mServiceMockUserToken {
	mmUserToken.optional = true
	return mmUserToken
}

// Expect sets up expected params for Service.UserToken
func (mmUserToken *mServiceMockUserToken) Expect(ctx context.Context, username string, password string) *mServiceMockUserToken {
	if mmUserToken.mock.funcUserToken != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Set")
	}

	if mmUserToken.defaultExpectation == nil {
		mmUserToken.defaultExpectation = &ServiceMockUserTokenExpectation{}
	}

	if mmUserToken.defaultExpectation.paramPtrs != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by ExpectParams functions")
	}

	mmUserToken.defaultExpectation.params = &ServiceMockUserTokenParams{ctx, username, password}
	mmUserToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserToken.expectations {
		if minimock.Equal(e.params, mmUserToken.defaultExpectation.params) {
			mmUserToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserToken.defaultExpectation.params)
		}
	}

	return mmUserToken
}

// ExpectCtxParam1 sets up expected param ctx for Service.UserToken
func (mmUserToken *mServiceMockUserToken) ExpectCtxParam1(ctx context.Context) *mServiceMockUserToken {
	if mmUserToken.mock.funcUserToken != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Set")
	}

	if mmUserToken.defaultExpectation == nil {
		mmUserToken.defaultExpectation = &ServiceMockUserTokenExpectation{}
	}

	if mmUserToken.defaultExpectation.params != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Expect")
	}

	if mmUserToken.defaultExpectation.paramPtrs == nil {
		mmUserToken.defaultExpectation.paramPtrs = &ServiceMockUserTokenParamPtrs{}
	}
	mmUserToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserToken
}

// ExpectUsernameParam2 sets up expected param username for Service.UserToken
func (mmUserToken *mServiceMockUserToken) ExpectUsernameParam2(username string) *mServiceMockUserToken {
	if mmUserToken.mock.funcUserToken != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Set")
	}

	if mmUserToken.defaultExpectation == nil {
		mmUserToken.defaultExpectation = &ServiceMockUserTokenExpectation{}
	}

	if mmUserToken.defaultExpectation.params != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Expect")
	}

	if mmUserToken.defaultExpectation.paramPtrs == nil {
		mmUserToken.defaultExpectation.paramPtrs = &ServiceMockUserTokenParamPtrs{}
	}
	mmUserToken.defaultExpectation.paramPtrs.username = &username
	mmUserToken.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmUserToken
}

// ExpectPasswordParam3 sets up expected param password for Service.UserToken
func (mmUserToken *mServiceMockUserToken) ExpectPasswordParam3(password string) *mServiceMockUserToken {
	if mmUserToken.mock.funcUserToken != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Set")
	}

	if mmUserToken.defaultExpectation == nil {
		mmUserToken.defaultExpectation = &ServiceMockUserTokenExpectation{}
	}

	if mmUserToken.defaultExpectation.params != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Expect")
	}

	if mmUserToken.defaultExpectation.paramPtrs == nil {
		mmUserToken.defaultExpectation.paramPtrs = &ServiceMockUserTokenParamPtrs{}
	}
	mmUserToken.defaultExpectation.paramPtrs.password = &password
	mmUserToken.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmUserToken
}

// Inspect accepts an inspector function that has same arguments as the Service.UserToken
func (mmUserToken *mServiceMockUserToken) Inspect(f func(ctx context.Context, username string, password string)) *mServiceMockUserToken {
	if mmUserToken.mock.inspectFuncUserToken != nil {
		mmUserToken.mock.t.Fatalf("Inspect function is already set for ServiceMock.UserToken")
	}

	mmUserToken.mock.inspectFuncUserToken = f

	return mmUserToken
}

// Return sets up results that will be returned by Service.UserToken
func (mmUserToken *mServiceMockUserToken) Return(s1 string, err error) *ServiceMock {
	if mmUserToken.mock.funcUserToken != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Set")
	}

	if mmUserToken.defaultExpectation == nil {
		mmUserToken.defaultExpectation = &ServiceMockUserTokenExpectation{mock: mmUserToken.mock}
	}
	mmUserToken.defaultExpectation.results = &ServiceMockUserTokenResults{s1, err}
	mmUserToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserToken.mock
}

// Set uses given function f to mock the Service.UserToken method
func (mmUserToken *mServiceMockUserToken) Set(f func(ctx context.Context, username string, password string) (s1 string, err error)) *ServiceMock {
	if mmUserToken.defaultExpectation != nil {
		mmUserToken.mock.t.Fatalf("Default expectation is already set for the Service.UserToken method")
	}

	if len(mmUserToken.expectations) > 0 {
		mmUserToken.mock.t.Fatalf("Some expectations are already set for the Service.UserToken method")
	}

	mmUserToken.mock.funcUserToken = f
	mmUserToken.mock.funcUserTokenOrigin = minimock.CallerInfo(1)
	return mmUserToken.mock
}

// When sets expectation for the Service.UserToken which will trigger the result defined by the following
// Then helper
func (mmUserToken *mServiceMockUserToken) When(ctx context.Context, username string, password string) *ServiceMockUserTokenExpectation {
	if mmUserToken.mock.funcUserToken != nil {
		mmUserToken.mock.t.Fatalf("ServiceMock.UserToken mock is already set by Set")
	}

	expectation := &ServiceMockUserTokenExpectation{
		mock:               mmUserToken.mock,
		params:             &ServiceMockUserTokenParams{ctx, username, password},
		expectationOrigins: ServiceMockUserTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserToken.expectations = append(mmUserToken.expectations, expectation)
	return expectation
}

// Then sets up Service.UserToken return parameters for the expectation previously defined by the When method
func (e *ServiceMockUserTokenExpectation) Then(s1 string, err error) *ServiceMock {
	e.results = &ServiceMockUserTokenResults{s1, err}
	return e.mock
}

// Times sets number of times Service.UserToken should be invoked
func (mmUserToken *mServiceMockUserToken) Times(n uint64) *mServiceMockUserToken {
	if n == 0 {
		mmUserToken.mock.t.Fatalf("Times of ServiceMock.UserToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserToken.expectedInvocations, n)
	mmUserToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserToken
}

func (mmUserToken *mServiceMockUserToken) invocationsDone() bool {
	if len(mmUserToken.expectations) == 0 && mmUserToken.defaultExpectation == nil && mmUserToken.mock.funcUserToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserToken.mock.afterUserTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserToken implements mm_service.Service
func (mmUserToken *ServiceMock) UserToken(ctx context.Context, username string, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmUserToken.beforeUserTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmUserToken.afterUserTokenCounter, 1)

	mmUserToken.t.Helper()

	if mmUserToken.inspectFuncUserToken != nil {
		mmUserToken.inspectFuncUserToken(ctx, username, password)
	}

	mm_params := ServiceMockUserTokenParams{ctx, username, password}

	// Record call args
	mmUserToken.UserTokenMock.mutex.Lock()
	mmUserToken.UserTokenMock.callArgs = append(mmUserToken.UserTokenMock.callArgs, &mm_params)
	mmUserToken.UserTokenMock.mutex.Unlock()

	for _, e := range mmUserToken.UserTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmUserToken.UserTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserToken.UserTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmUserToken.UserTokenMock.defaultExpectation.params
		mm_want_ptrs := mmUserToken.UserTokenMock.defaultExpectation.paramPtrs

		mm_got := ServiceMockUserTokenParams{ctx, username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserToken.t.Errorf("ServiceMock.UserToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserToken.UserTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmUserToken.t.Errorf("ServiceMock.UserToken got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserToken.UserTokenMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmUserToken.t.Errorf("ServiceMock.UserToken got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserToken.UserTokenMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserToken.t.Errorf("ServiceMock.UserToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserToken.UserTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserToken.UserTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmUserToken.t.Fatal("No results are set for the ServiceMock.UserToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmUserToken.funcUserToken != nil {
		return mmUserToken.funcUserToken(ctx, username, password)
	}
	mmUserToken.t.Fatalf("Unexpected call to ServiceMock.UserToken. %v %v %v", ctx, username, password)
	return
}

// UserTokenAfterCounter returns a count of finished ServiceMock.UserToken invocations
func (mmUserToken *ServiceMock) UserTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserToken.afterUserTokenCounter)
}

// UserTokenBeforeCounter returns a count of ServiceMock.UserToken invocations
func (mmUserToken *ServiceMock) UserTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserToken.beforeUserTokenCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UserToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserToken *mServiceMockUserToken) Calls() []*ServiceMockUserTokenParams {
	mmUserToken.mutex.RLock()

	argCopy := make([]*ServiceMockUserTokenParams, len(mmUserToken.callArgs))
	copy(argCopy, mmUserToken.callArgs)

	mmUserToken.mutex.RUnlock()

	return argCopy
}

// MinimockUserTokenDone returns true if the count of the UserToken invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUserTokenDone() bool {
	if m.UserTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserTokenMock.invocationsDone()
}

// MinimockUserTokenInspect logs each unmet expectation
func (m *ServiceMock) MinimockUserTokenInspect() {
	for _, e := range m.UserTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UserToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserTokenCounter := mm_atomic.LoadUint64(&m.afterUserTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserTokenMock.defaultExpectation != nil && afterUserTokenCounter < 1 {
		if m.UserTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceMock.UserToken at\n%s", m.UserTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceMock.UserToken at\n%s with params: %#v", m.UserTokenMock.defaultExpectation.expectationOrigins.origin, *m.UserTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserToken != nil && afterUserTokenCounter < 1 {
		m.t.Errorf("Expected call to ServiceMock.UserToken at\n%s", m.funcUserTokenOrigin)
	}

	if !m.UserTokenMock.invocationsDone() && afterUserTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceMock.UserToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserTokenMock.expectedInvocations), m.UserTokenMock.expectedInvocationsOrigin, afterUserTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBuyItemInspect()

			m.MinimockSendCoinInspect()

			m.MinimockUserInfoInspect()

			m.MinimockUserTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuyItemDone() &&
		m.MinimockSendCoinDone() &&
		m.MinimockUserInfoDone() &&
		m.MinimockUserTokenDone()
}
