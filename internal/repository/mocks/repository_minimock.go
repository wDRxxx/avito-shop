// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/wDRxxx/avito-shop/internal/repository.Repository -o repository_minimock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	rm "github.com/wDRxxx/avito-shop/internal/repository/models"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBuyItem          func(ctx context.Context, userID int, item *rm.Item) (err error)
	funcBuyItemOrigin    string
	inspectFuncBuyItem   func(ctx context.Context, userID int, item *rm.Item)
	afterBuyItemCounter  uint64
	beforeBuyItemCounter uint64
	BuyItemMock          mRepositoryMockBuyItem

	funcInsertUser          func(ctx context.Context, username string, password string) (up1 *rm.User, err error)
	funcInsertUserOrigin    string
	inspectFuncInsertUser   func(ctx context.Context, username string, password string)
	afterInsertUserCounter  uint64
	beforeInsertUserCounter uint64
	InsertUserMock          mRepositoryMockInsertUser

	funcItem          func(ctx context.Context, title string) (ip1 *rm.Item, err error)
	funcItemOrigin    string
	inspectFuncItem   func(ctx context.Context, title string)
	afterItemCounter  uint64
	beforeItemCounter uint64
	ItemMock          mRepositoryMockItem

	funcSendCoin          func(ctx context.Context, toUserID int, fromUserID int, amount int) (err error)
	funcSendCoinOrigin    string
	inspectFuncSendCoin   func(ctx context.Context, toUserID int, fromUserID int, amount int)
	afterSendCoinCounter  uint64
	beforeSendCoinCounter uint64
	SendCoinMock          mRepositoryMockSendCoin

	funcUserByID          func(ctx context.Context, userID int) (up1 *rm.User, err error)
	funcUserByIDOrigin    string
	inspectFuncUserByID   func(ctx context.Context, userID int)
	afterUserByIDCounter  uint64
	beforeUserByIDCounter uint64
	UserByIDMock          mRepositoryMockUserByID

	funcUserByUsername          func(ctx context.Context, username string) (up1 *rm.User, err error)
	funcUserByUsernameOrigin    string
	inspectFuncUserByUsername   func(ctx context.Context, username string)
	afterUserByUsernameCounter  uint64
	beforeUserByUsernameCounter uint64
	UserByUsernameMock          mRepositoryMockUserByUsername

	funcUserIncomingTransactions          func(ctx context.Context, userID int) (tpa1 []*rm.Transaction, err error)
	funcUserIncomingTransactionsOrigin    string
	inspectFuncUserIncomingTransactions   func(ctx context.Context, userID int)
	afterUserIncomingTransactionsCounter  uint64
	beforeUserIncomingTransactionsCounter uint64
	UserIncomingTransactionsMock          mRepositoryMockUserIncomingTransactions

	funcUserInventory          func(ctx context.Context, userID int) (ipa1 []*rm.InventoryItem, err error)
	funcUserInventoryOrigin    string
	inspectFuncUserInventory   func(ctx context.Context, userID int)
	afterUserInventoryCounter  uint64
	beforeUserInventoryCounter uint64
	UserInventoryMock          mRepositoryMockUserInventory

	funcUserOutgoingTransactions          func(ctx context.Context, userID int) (tpa1 []*rm.Transaction, err error)
	funcUserOutgoingTransactionsOrigin    string
	inspectFuncUserOutgoingTransactions   func(ctx context.Context, userID int)
	afterUserOutgoingTransactionsCounter  uint64
	beforeUserOutgoingTransactionsCounter uint64
	UserOutgoingTransactionsMock          mRepositoryMockUserOutgoingTransactions
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BuyItemMock = mRepositoryMockBuyItem{mock: m}
	m.BuyItemMock.callArgs = []*RepositoryMockBuyItemParams{}

	m.InsertUserMock = mRepositoryMockInsertUser{mock: m}
	m.InsertUserMock.callArgs = []*RepositoryMockInsertUserParams{}

	m.ItemMock = mRepositoryMockItem{mock: m}
	m.ItemMock.callArgs = []*RepositoryMockItemParams{}

	m.SendCoinMock = mRepositoryMockSendCoin{mock: m}
	m.SendCoinMock.callArgs = []*RepositoryMockSendCoinParams{}

	m.UserByIDMock = mRepositoryMockUserByID{mock: m}
	m.UserByIDMock.callArgs = []*RepositoryMockUserByIDParams{}

	m.UserByUsernameMock = mRepositoryMockUserByUsername{mock: m}
	m.UserByUsernameMock.callArgs = []*RepositoryMockUserByUsernameParams{}

	m.UserIncomingTransactionsMock = mRepositoryMockUserIncomingTransactions{mock: m}
	m.UserIncomingTransactionsMock.callArgs = []*RepositoryMockUserIncomingTransactionsParams{}

	m.UserInventoryMock = mRepositoryMockUserInventory{mock: m}
	m.UserInventoryMock.callArgs = []*RepositoryMockUserInventoryParams{}

	m.UserOutgoingTransactionsMock = mRepositoryMockUserOutgoingTransactions{mock: m}
	m.UserOutgoingTransactionsMock.callArgs = []*RepositoryMockUserOutgoingTransactionsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockBuyItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockBuyItemExpectation
	expectations       []*RepositoryMockBuyItemExpectation

	callArgs []*RepositoryMockBuyItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockBuyItemExpectation specifies expectation struct of the Repository.BuyItem
type RepositoryMockBuyItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockBuyItemParams
	paramPtrs          *RepositoryMockBuyItemParamPtrs
	expectationOrigins RepositoryMockBuyItemExpectationOrigins
	results            *RepositoryMockBuyItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockBuyItemParams contains parameters of the Repository.BuyItem
type RepositoryMockBuyItemParams struct {
	ctx    context.Context
	userID int
	item   *rm.Item
}

// RepositoryMockBuyItemParamPtrs contains pointers to parameters of the Repository.BuyItem
type RepositoryMockBuyItemParamPtrs struct {
	ctx    *context.Context
	userID *int
	item   **rm.Item
}

// RepositoryMockBuyItemResults contains results of the Repository.BuyItem
type RepositoryMockBuyItemResults struct {
	err error
}

// RepositoryMockBuyItemOrigins contains origins of expectations of the Repository.BuyItem
type RepositoryMockBuyItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItem   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBuyItem *mRepositoryMockBuyItem) Optional() *mRepositoryMockBuyItem {
	mmBuyItem.optional = true
	return mmBuyItem
}

// Expect sets up expected params for Repository.BuyItem
func (mmBuyItem *mRepositoryMockBuyItem) Expect(ctx context.Context, userID int, item *rm.Item) *mRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &RepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.paramPtrs != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by ExpectParams functions")
	}

	mmBuyItem.defaultExpectation.params = &RepositoryMockBuyItemParams{ctx, userID, item}
	mmBuyItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBuyItem.expectations {
		if minimock.Equal(e.params, mmBuyItem.defaultExpectation.params) {
			mmBuyItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBuyItem.defaultExpectation.params)
		}
	}

	return mmBuyItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.BuyItem
func (mmBuyItem *mRepositoryMockBuyItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &RepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &RepositoryMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmBuyItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBuyItem
}

// ExpectUserIDParam2 sets up expected param userID for Repository.BuyItem
func (mmBuyItem *mRepositoryMockBuyItem) ExpectUserIDParam2(userID int) *mRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &RepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &RepositoryMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.userID = &userID
	mmBuyItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmBuyItem
}

// ExpectItemParam3 sets up expected param item for Repository.BuyItem
func (mmBuyItem *mRepositoryMockBuyItem) ExpectItemParam3(item *rm.Item) *mRepositoryMockBuyItem {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &RepositoryMockBuyItemExpectation{}
	}

	if mmBuyItem.defaultExpectation.params != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Expect")
	}

	if mmBuyItem.defaultExpectation.paramPtrs == nil {
		mmBuyItem.defaultExpectation.paramPtrs = &RepositoryMockBuyItemParamPtrs{}
	}
	mmBuyItem.defaultExpectation.paramPtrs.item = &item
	mmBuyItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmBuyItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.BuyItem
func (mmBuyItem *mRepositoryMockBuyItem) Inspect(f func(ctx context.Context, userID int, item *rm.Item)) *mRepositoryMockBuyItem {
	if mmBuyItem.mock.inspectFuncBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.BuyItem")
	}

	mmBuyItem.mock.inspectFuncBuyItem = f

	return mmBuyItem
}

// Return sets up results that will be returned by Repository.BuyItem
func (mmBuyItem *mRepositoryMockBuyItem) Return(err error) *RepositoryMock {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Set")
	}

	if mmBuyItem.defaultExpectation == nil {
		mmBuyItem.defaultExpectation = &RepositoryMockBuyItemExpectation{mock: mmBuyItem.mock}
	}
	mmBuyItem.defaultExpectation.results = &RepositoryMockBuyItemResults{err}
	mmBuyItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBuyItem.mock
}

// Set uses given function f to mock the Repository.BuyItem method
func (mmBuyItem *mRepositoryMockBuyItem) Set(f func(ctx context.Context, userID int, item *rm.Item) (err error)) *RepositoryMock {
	if mmBuyItem.defaultExpectation != nil {
		mmBuyItem.mock.t.Fatalf("Default expectation is already set for the Repository.BuyItem method")
	}

	if len(mmBuyItem.expectations) > 0 {
		mmBuyItem.mock.t.Fatalf("Some expectations are already set for the Repository.BuyItem method")
	}

	mmBuyItem.mock.funcBuyItem = f
	mmBuyItem.mock.funcBuyItemOrigin = minimock.CallerInfo(1)
	return mmBuyItem.mock
}

// When sets expectation for the Repository.BuyItem which will trigger the result defined by the following
// Then helper
func (mmBuyItem *mRepositoryMockBuyItem) When(ctx context.Context, userID int, item *rm.Item) *RepositoryMockBuyItemExpectation {
	if mmBuyItem.mock.funcBuyItem != nil {
		mmBuyItem.mock.t.Fatalf("RepositoryMock.BuyItem mock is already set by Set")
	}

	expectation := &RepositoryMockBuyItemExpectation{
		mock:               mmBuyItem.mock,
		params:             &RepositoryMockBuyItemParams{ctx, userID, item},
		expectationOrigins: RepositoryMockBuyItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBuyItem.expectations = append(mmBuyItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.BuyItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockBuyItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockBuyItemResults{err}
	return e.mock
}

// Times sets number of times Repository.BuyItem should be invoked
func (mmBuyItem *mRepositoryMockBuyItem) Times(n uint64) *mRepositoryMockBuyItem {
	if n == 0 {
		mmBuyItem.mock.t.Fatalf("Times of RepositoryMock.BuyItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBuyItem.expectedInvocations, n)
	mmBuyItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBuyItem
}

func (mmBuyItem *mRepositoryMockBuyItem) invocationsDone() bool {
	if len(mmBuyItem.expectations) == 0 && mmBuyItem.defaultExpectation == nil && mmBuyItem.mock.funcBuyItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBuyItem.mock.afterBuyItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBuyItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BuyItem implements mm_repository.Repository
func (mmBuyItem *RepositoryMock) BuyItem(ctx context.Context, userID int, item *rm.Item) (err error) {
	mm_atomic.AddUint64(&mmBuyItem.beforeBuyItemCounter, 1)
	defer mm_atomic.AddUint64(&mmBuyItem.afterBuyItemCounter, 1)

	mmBuyItem.t.Helper()

	if mmBuyItem.inspectFuncBuyItem != nil {
		mmBuyItem.inspectFuncBuyItem(ctx, userID, item)
	}

	mm_params := RepositoryMockBuyItemParams{ctx, userID, item}

	// Record call args
	mmBuyItem.BuyItemMock.mutex.Lock()
	mmBuyItem.BuyItemMock.callArgs = append(mmBuyItem.BuyItemMock.callArgs, &mm_params)
	mmBuyItem.BuyItemMock.mutex.Unlock()

	for _, e := range mmBuyItem.BuyItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBuyItem.BuyItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBuyItem.BuyItemMock.defaultExpectation.Counter, 1)
		mm_want := mmBuyItem.BuyItemMock.defaultExpectation.params
		mm_want_ptrs := mmBuyItem.BuyItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockBuyItemParams{ctx, userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBuyItem.t.Errorf("RepositoryMock.BuyItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmBuyItem.t.Errorf("RepositoryMock.BuyItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmBuyItem.t.Errorf("RepositoryMock.BuyItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBuyItem.t.Errorf("RepositoryMock.BuyItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBuyItem.BuyItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBuyItem.BuyItemMock.defaultExpectation.results
		if mm_results == nil {
			mmBuyItem.t.Fatal("No results are set for the RepositoryMock.BuyItem")
		}
		return (*mm_results).err
	}
	if mmBuyItem.funcBuyItem != nil {
		return mmBuyItem.funcBuyItem(ctx, userID, item)
	}
	mmBuyItem.t.Fatalf("Unexpected call to RepositoryMock.BuyItem. %v %v %v", ctx, userID, item)
	return
}

// BuyItemAfterCounter returns a count of finished RepositoryMock.BuyItem invocations
func (mmBuyItem *RepositoryMock) BuyItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyItem.afterBuyItemCounter)
}

// BuyItemBeforeCounter returns a count of RepositoryMock.BuyItem invocations
func (mmBuyItem *RepositoryMock) BuyItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBuyItem.beforeBuyItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.BuyItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBuyItem *mRepositoryMockBuyItem) Calls() []*RepositoryMockBuyItemParams {
	mmBuyItem.mutex.RLock()

	argCopy := make([]*RepositoryMockBuyItemParams, len(mmBuyItem.callArgs))
	copy(argCopy, mmBuyItem.callArgs)

	mmBuyItem.mutex.RUnlock()

	return argCopy
}

// MinimockBuyItemDone returns true if the count of the BuyItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockBuyItemDone() bool {
	if m.BuyItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BuyItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BuyItemMock.invocationsDone()
}

// MinimockBuyItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockBuyItemInspect() {
	for _, e := range m.BuyItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.BuyItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBuyItemCounter := mm_atomic.LoadUint64(&m.afterBuyItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BuyItemMock.defaultExpectation != nil && afterBuyItemCounter < 1 {
		if m.BuyItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.BuyItem at\n%s", m.BuyItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.BuyItem at\n%s with params: %#v", m.BuyItemMock.defaultExpectation.expectationOrigins.origin, *m.BuyItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBuyItem != nil && afterBuyItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.BuyItem at\n%s", m.funcBuyItemOrigin)
	}

	if !m.BuyItemMock.invocationsDone() && afterBuyItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.BuyItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BuyItemMock.expectedInvocations), m.BuyItemMock.expectedInvocationsOrigin, afterBuyItemCounter)
	}
}

type mRepositoryMockInsertUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockInsertUserExpectation
	expectations       []*RepositoryMockInsertUserExpectation

	callArgs []*RepositoryMockInsertUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockInsertUserExpectation specifies expectation struct of the Repository.InsertUser
type RepositoryMockInsertUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockInsertUserParams
	paramPtrs          *RepositoryMockInsertUserParamPtrs
	expectationOrigins RepositoryMockInsertUserExpectationOrigins
	results            *RepositoryMockInsertUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockInsertUserParams contains parameters of the Repository.InsertUser
type RepositoryMockInsertUserParams struct {
	ctx      context.Context
	username string
	password string
}

// RepositoryMockInsertUserParamPtrs contains pointers to parameters of the Repository.InsertUser
type RepositoryMockInsertUserParamPtrs struct {
	ctx      *context.Context
	username *string
	password *string
}

// RepositoryMockInsertUserResults contains results of the Repository.InsertUser
type RepositoryMockInsertUserResults struct {
	up1 *rm.User
	err error
}

// RepositoryMockInsertUserOrigins contains origins of expectations of the Repository.InsertUser
type RepositoryMockInsertUserExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertUser *mRepositoryMockInsertUser) Optional() *mRepositoryMockInsertUser {
	mmInsertUser.optional = true
	return mmInsertUser
}

// Expect sets up expected params for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) Expect(ctx context.Context, username string, password string) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.paramPtrs != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by ExpectParams functions")
	}

	mmInsertUser.defaultExpectation.params = &RepositoryMockInsertUserParams{ctx, username, password}
	mmInsertUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertUser.expectations {
		if minimock.Equal(e.params, mmInsertUser.defaultExpectation.params) {
			mmInsertUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertUser.defaultExpectation.params)
		}
	}

	return mmInsertUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.params != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Expect")
	}

	if mmInsertUser.defaultExpectation.paramPtrs == nil {
		mmInsertUser.defaultExpectation.paramPtrs = &RepositoryMockInsertUserParamPtrs{}
	}
	mmInsertUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertUser
}

// ExpectUsernameParam2 sets up expected param username for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) ExpectUsernameParam2(username string) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.params != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Expect")
	}

	if mmInsertUser.defaultExpectation.paramPtrs == nil {
		mmInsertUser.defaultExpectation.paramPtrs = &RepositoryMockInsertUserParamPtrs{}
	}
	mmInsertUser.defaultExpectation.paramPtrs.username = &username
	mmInsertUser.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmInsertUser
}

// ExpectPasswordParam3 sets up expected param password for Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) ExpectPasswordParam3(password string) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{}
	}

	if mmInsertUser.defaultExpectation.params != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Expect")
	}

	if mmInsertUser.defaultExpectation.paramPtrs == nil {
		mmInsertUser.defaultExpectation.paramPtrs = &RepositoryMockInsertUserParamPtrs{}
	}
	mmInsertUser.defaultExpectation.paramPtrs.password = &password
	mmInsertUser.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmInsertUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) Inspect(f func(ctx context.Context, username string, password string)) *mRepositoryMockInsertUser {
	if mmInsertUser.mock.inspectFuncInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.InsertUser")
	}

	mmInsertUser.mock.inspectFuncInsertUser = f

	return mmInsertUser
}

// Return sets up results that will be returned by Repository.InsertUser
func (mmInsertUser *mRepositoryMockInsertUser) Return(up1 *rm.User, err error) *RepositoryMock {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	if mmInsertUser.defaultExpectation == nil {
		mmInsertUser.defaultExpectation = &RepositoryMockInsertUserExpectation{mock: mmInsertUser.mock}
	}
	mmInsertUser.defaultExpectation.results = &RepositoryMockInsertUserResults{up1, err}
	mmInsertUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertUser.mock
}

// Set uses given function f to mock the Repository.InsertUser method
func (mmInsertUser *mRepositoryMockInsertUser) Set(f func(ctx context.Context, username string, password string) (up1 *rm.User, err error)) *RepositoryMock {
	if mmInsertUser.defaultExpectation != nil {
		mmInsertUser.mock.t.Fatalf("Default expectation is already set for the Repository.InsertUser method")
	}

	if len(mmInsertUser.expectations) > 0 {
		mmInsertUser.mock.t.Fatalf("Some expectations are already set for the Repository.InsertUser method")
	}

	mmInsertUser.mock.funcInsertUser = f
	mmInsertUser.mock.funcInsertUserOrigin = minimock.CallerInfo(1)
	return mmInsertUser.mock
}

// When sets expectation for the Repository.InsertUser which will trigger the result defined by the following
// Then helper
func (mmInsertUser *mRepositoryMockInsertUser) When(ctx context.Context, username string, password string) *RepositoryMockInsertUserExpectation {
	if mmInsertUser.mock.funcInsertUser != nil {
		mmInsertUser.mock.t.Fatalf("RepositoryMock.InsertUser mock is already set by Set")
	}

	expectation := &RepositoryMockInsertUserExpectation{
		mock:               mmInsertUser.mock,
		params:             &RepositoryMockInsertUserParams{ctx, username, password},
		expectationOrigins: RepositoryMockInsertUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertUser.expectations = append(mmInsertUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.InsertUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockInsertUserExpectation) Then(up1 *rm.User, err error) *RepositoryMock {
	e.results = &RepositoryMockInsertUserResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.InsertUser should be invoked
func (mmInsertUser *mRepositoryMockInsertUser) Times(n uint64) *mRepositoryMockInsertUser {
	if n == 0 {
		mmInsertUser.mock.t.Fatalf("Times of RepositoryMock.InsertUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertUser.expectedInvocations, n)
	mmInsertUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertUser
}

func (mmInsertUser *mRepositoryMockInsertUser) invocationsDone() bool {
	if len(mmInsertUser.expectations) == 0 && mmInsertUser.defaultExpectation == nil && mmInsertUser.mock.funcInsertUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertUser.mock.afterInsertUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertUser implements mm_repository.Repository
func (mmInsertUser *RepositoryMock) InsertUser(ctx context.Context, username string, password string) (up1 *rm.User, err error) {
	mm_atomic.AddUint64(&mmInsertUser.beforeInsertUserCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertUser.afterInsertUserCounter, 1)

	mmInsertUser.t.Helper()

	if mmInsertUser.inspectFuncInsertUser != nil {
		mmInsertUser.inspectFuncInsertUser(ctx, username, password)
	}

	mm_params := RepositoryMockInsertUserParams{ctx, username, password}

	// Record call args
	mmInsertUser.InsertUserMock.mutex.Lock()
	mmInsertUser.InsertUserMock.callArgs = append(mmInsertUser.InsertUserMock.callArgs, &mm_params)
	mmInsertUser.InsertUserMock.mutex.Unlock()

	for _, e := range mmInsertUser.InsertUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmInsertUser.InsertUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertUser.InsertUserMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertUser.InsertUserMock.defaultExpectation.params
		mm_want_ptrs := mmInsertUser.InsertUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockInsertUserParams{ctx, username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertUser.t.Errorf("RepositoryMock.InsertUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertUser.InsertUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertUser.InsertUserMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertUser.t.Fatal("No results are set for the RepositoryMock.InsertUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmInsertUser.funcInsertUser != nil {
		return mmInsertUser.funcInsertUser(ctx, username, password)
	}
	mmInsertUser.t.Fatalf("Unexpected call to RepositoryMock.InsertUser. %v %v %v", ctx, username, password)
	return
}

// InsertUserAfterCounter returns a count of finished RepositoryMock.InsertUser invocations
func (mmInsertUser *RepositoryMock) InsertUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertUser.afterInsertUserCounter)
}

// InsertUserBeforeCounter returns a count of RepositoryMock.InsertUser invocations
func (mmInsertUser *RepositoryMock) InsertUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertUser.beforeInsertUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.InsertUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertUser *mRepositoryMockInsertUser) Calls() []*RepositoryMockInsertUserParams {
	mmInsertUser.mutex.RLock()

	argCopy := make([]*RepositoryMockInsertUserParams, len(mmInsertUser.callArgs))
	copy(argCopy, mmInsertUser.callArgs)

	mmInsertUser.mutex.RUnlock()

	return argCopy
}

// MinimockInsertUserDone returns true if the count of the InsertUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockInsertUserDone() bool {
	if m.InsertUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertUserMock.invocationsDone()
}

// MinimockInsertUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockInsertUserInspect() {
	for _, e := range m.InsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertUserCounter := mm_atomic.LoadUint64(&m.afterInsertUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertUserMock.defaultExpectation != nil && afterInsertUserCounter < 1 {
		if m.InsertUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s", m.InsertUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s with params: %#v", m.InsertUserMock.defaultExpectation.expectationOrigins.origin, *m.InsertUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertUser != nil && afterInsertUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.InsertUser at\n%s", m.funcInsertUserOrigin)
	}

	if !m.InsertUserMock.invocationsDone() && afterInsertUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.InsertUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertUserMock.expectedInvocations), m.InsertUserMock.expectedInvocationsOrigin, afterInsertUserCounter)
	}
}

type mRepositoryMockItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockItemExpectation
	expectations       []*RepositoryMockItemExpectation

	callArgs []*RepositoryMockItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockItemExpectation specifies expectation struct of the Repository.Item
type RepositoryMockItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockItemParams
	paramPtrs          *RepositoryMockItemParamPtrs
	expectationOrigins RepositoryMockItemExpectationOrigins
	results            *RepositoryMockItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockItemParams contains parameters of the Repository.Item
type RepositoryMockItemParams struct {
	ctx   context.Context
	title string
}

// RepositoryMockItemParamPtrs contains pointers to parameters of the Repository.Item
type RepositoryMockItemParamPtrs struct {
	ctx   *context.Context
	title *string
}

// RepositoryMockItemResults contains results of the Repository.Item
type RepositoryMockItemResults struct {
	ip1 *rm.Item
	err error
}

// RepositoryMockItemOrigins contains origins of expectations of the Repository.Item
type RepositoryMockItemExpectationOrigins struct {
	origin      string
	originCtx   string
	originTitle string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmItem *mRepositoryMockItem) Optional() *mRepositoryMockItem {
	mmItem.optional = true
	return mmItem
}

// Expect sets up expected params for Repository.Item
func (mmItem *mRepositoryMockItem) Expect(ctx context.Context, title string) *mRepositoryMockItem {
	if mmItem.mock.funcItem != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Set")
	}

	if mmItem.defaultExpectation == nil {
		mmItem.defaultExpectation = &RepositoryMockItemExpectation{}
	}

	if mmItem.defaultExpectation.paramPtrs != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by ExpectParams functions")
	}

	mmItem.defaultExpectation.params = &RepositoryMockItemParams{ctx, title}
	mmItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmItem.expectations {
		if minimock.Equal(e.params, mmItem.defaultExpectation.params) {
			mmItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmItem.defaultExpectation.params)
		}
	}

	return mmItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Item
func (mmItem *mRepositoryMockItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockItem {
	if mmItem.mock.funcItem != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Set")
	}

	if mmItem.defaultExpectation == nil {
		mmItem.defaultExpectation = &RepositoryMockItemExpectation{}
	}

	if mmItem.defaultExpectation.params != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Expect")
	}

	if mmItem.defaultExpectation.paramPtrs == nil {
		mmItem.defaultExpectation.paramPtrs = &RepositoryMockItemParamPtrs{}
	}
	mmItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmItem
}

// ExpectTitleParam2 sets up expected param title for Repository.Item
func (mmItem *mRepositoryMockItem) ExpectTitleParam2(title string) *mRepositoryMockItem {
	if mmItem.mock.funcItem != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Set")
	}

	if mmItem.defaultExpectation == nil {
		mmItem.defaultExpectation = &RepositoryMockItemExpectation{}
	}

	if mmItem.defaultExpectation.params != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Expect")
	}

	if mmItem.defaultExpectation.paramPtrs == nil {
		mmItem.defaultExpectation.paramPtrs = &RepositoryMockItemParamPtrs{}
	}
	mmItem.defaultExpectation.paramPtrs.title = &title
	mmItem.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.Item
func (mmItem *mRepositoryMockItem) Inspect(f func(ctx context.Context, title string)) *mRepositoryMockItem {
	if mmItem.mock.inspectFuncItem != nil {
		mmItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Item")
	}

	mmItem.mock.inspectFuncItem = f

	return mmItem
}

// Return sets up results that will be returned by Repository.Item
func (mmItem *mRepositoryMockItem) Return(ip1 *rm.Item, err error) *RepositoryMock {
	if mmItem.mock.funcItem != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Set")
	}

	if mmItem.defaultExpectation == nil {
		mmItem.defaultExpectation = &RepositoryMockItemExpectation{mock: mmItem.mock}
	}
	mmItem.defaultExpectation.results = &RepositoryMockItemResults{ip1, err}
	mmItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmItem.mock
}

// Set uses given function f to mock the Repository.Item method
func (mmItem *mRepositoryMockItem) Set(f func(ctx context.Context, title string) (ip1 *rm.Item, err error)) *RepositoryMock {
	if mmItem.defaultExpectation != nil {
		mmItem.mock.t.Fatalf("Default expectation is already set for the Repository.Item method")
	}

	if len(mmItem.expectations) > 0 {
		mmItem.mock.t.Fatalf("Some expectations are already set for the Repository.Item method")
	}

	mmItem.mock.funcItem = f
	mmItem.mock.funcItemOrigin = minimock.CallerInfo(1)
	return mmItem.mock
}

// When sets expectation for the Repository.Item which will trigger the result defined by the following
// Then helper
func (mmItem *mRepositoryMockItem) When(ctx context.Context, title string) *RepositoryMockItemExpectation {
	if mmItem.mock.funcItem != nil {
		mmItem.mock.t.Fatalf("RepositoryMock.Item mock is already set by Set")
	}

	expectation := &RepositoryMockItemExpectation{
		mock:               mmItem.mock,
		params:             &RepositoryMockItemParams{ctx, title},
		expectationOrigins: RepositoryMockItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmItem.expectations = append(mmItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.Item return parameters for the expectation previously defined by the When method
func (e *RepositoryMockItemExpectation) Then(ip1 *rm.Item, err error) *RepositoryMock {
	e.results = &RepositoryMockItemResults{ip1, err}
	return e.mock
}

// Times sets number of times Repository.Item should be invoked
func (mmItem *mRepositoryMockItem) Times(n uint64) *mRepositoryMockItem {
	if n == 0 {
		mmItem.mock.t.Fatalf("Times of RepositoryMock.Item mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmItem.expectedInvocations, n)
	mmItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmItem
}

func (mmItem *mRepositoryMockItem) invocationsDone() bool {
	if len(mmItem.expectations) == 0 && mmItem.defaultExpectation == nil && mmItem.mock.funcItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmItem.mock.afterItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Item implements mm_repository.Repository
func (mmItem *RepositoryMock) Item(ctx context.Context, title string) (ip1 *rm.Item, err error) {
	mm_atomic.AddUint64(&mmItem.beforeItemCounter, 1)
	defer mm_atomic.AddUint64(&mmItem.afterItemCounter, 1)

	mmItem.t.Helper()

	if mmItem.inspectFuncItem != nil {
		mmItem.inspectFuncItem(ctx, title)
	}

	mm_params := RepositoryMockItemParams{ctx, title}

	// Record call args
	mmItem.ItemMock.mutex.Lock()
	mmItem.ItemMock.callArgs = append(mmItem.ItemMock.callArgs, &mm_params)
	mmItem.ItemMock.mutex.Unlock()

	for _, e := range mmItem.ItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmItem.ItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmItem.ItemMock.defaultExpectation.Counter, 1)
		mm_want := mmItem.ItemMock.defaultExpectation.params
		mm_want_ptrs := mmItem.ItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockItemParams{ctx, title}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmItem.t.Errorf("RepositoryMock.Item got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItem.ItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmItem.t.Errorf("RepositoryMock.Item got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmItem.ItemMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmItem.t.Errorf("RepositoryMock.Item got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmItem.ItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmItem.ItemMock.defaultExpectation.results
		if mm_results == nil {
			mmItem.t.Fatal("No results are set for the RepositoryMock.Item")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmItem.funcItem != nil {
		return mmItem.funcItem(ctx, title)
	}
	mmItem.t.Fatalf("Unexpected call to RepositoryMock.Item. %v %v", ctx, title)
	return
}

// ItemAfterCounter returns a count of finished RepositoryMock.Item invocations
func (mmItem *RepositoryMock) ItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItem.afterItemCounter)
}

// ItemBeforeCounter returns a count of RepositoryMock.Item invocations
func (mmItem *RepositoryMock) ItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmItem.beforeItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Item.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmItem *mRepositoryMockItem) Calls() []*RepositoryMockItemParams {
	mmItem.mutex.RLock()

	argCopy := make([]*RepositoryMockItemParams, len(mmItem.callArgs))
	copy(argCopy, mmItem.callArgs)

	mmItem.mutex.RUnlock()

	return argCopy
}

// MinimockItemDone returns true if the count of the Item invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockItemDone() bool {
	if m.ItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ItemMock.invocationsDone()
}

// MinimockItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockItemInspect() {
	for _, e := range m.ItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Item at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterItemCounter := mm_atomic.LoadUint64(&m.afterItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ItemMock.defaultExpectation != nil && afterItemCounter < 1 {
		if m.ItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Item at\n%s", m.ItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Item at\n%s with params: %#v", m.ItemMock.defaultExpectation.expectationOrigins.origin, *m.ItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcItem != nil && afterItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Item at\n%s", m.funcItemOrigin)
	}

	if !m.ItemMock.invocationsDone() && afterItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Item at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ItemMock.expectedInvocations), m.ItemMock.expectedInvocationsOrigin, afterItemCounter)
	}
}

type mRepositoryMockSendCoin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSendCoinExpectation
	expectations       []*RepositoryMockSendCoinExpectation

	callArgs []*RepositoryMockSendCoinParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSendCoinExpectation specifies expectation struct of the Repository.SendCoin
type RepositoryMockSendCoinExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSendCoinParams
	paramPtrs          *RepositoryMockSendCoinParamPtrs
	expectationOrigins RepositoryMockSendCoinExpectationOrigins
	results            *RepositoryMockSendCoinResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSendCoinParams contains parameters of the Repository.SendCoin
type RepositoryMockSendCoinParams struct {
	ctx        context.Context
	toUserID   int
	fromUserID int
	amount     int
}

// RepositoryMockSendCoinParamPtrs contains pointers to parameters of the Repository.SendCoin
type RepositoryMockSendCoinParamPtrs struct {
	ctx        *context.Context
	toUserID   *int
	fromUserID *int
	amount     *int
}

// RepositoryMockSendCoinResults contains results of the Repository.SendCoin
type RepositoryMockSendCoinResults struct {
	err error
}

// RepositoryMockSendCoinOrigins contains origins of expectations of the Repository.SendCoin
type RepositoryMockSendCoinExpectationOrigins struct {
	origin           string
	originCtx        string
	originToUserID   string
	originFromUserID string
	originAmount     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendCoin *mRepositoryMockSendCoin) Optional() *mRepositoryMockSendCoin {
	mmSendCoin.optional = true
	return mmSendCoin
}

// Expect sets up expected params for Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) Expect(ctx context.Context, toUserID int, fromUserID int, amount int) *mRepositoryMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &RepositoryMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.paramPtrs != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by ExpectParams functions")
	}

	mmSendCoin.defaultExpectation.params = &RepositoryMockSendCoinParams{ctx, toUserID, fromUserID, amount}
	mmSendCoin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendCoin.expectations {
		if minimock.Equal(e.params, mmSendCoin.defaultExpectation.params) {
			mmSendCoin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendCoin.defaultExpectation.params)
		}
	}

	return mmSendCoin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &RepositoryMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &RepositoryMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendCoin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendCoin
}

// ExpectToUserIDParam2 sets up expected param toUserID for Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) ExpectToUserIDParam2(toUserID int) *mRepositoryMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &RepositoryMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &RepositoryMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.toUserID = &toUserID
	mmSendCoin.defaultExpectation.expectationOrigins.originToUserID = minimock.CallerInfo(1)

	return mmSendCoin
}

// ExpectFromUserIDParam3 sets up expected param fromUserID for Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) ExpectFromUserIDParam3(fromUserID int) *mRepositoryMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &RepositoryMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &RepositoryMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.fromUserID = &fromUserID
	mmSendCoin.defaultExpectation.expectationOrigins.originFromUserID = minimock.CallerInfo(1)

	return mmSendCoin
}

// ExpectAmountParam4 sets up expected param amount for Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) ExpectAmountParam4(amount int) *mRepositoryMockSendCoin {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &RepositoryMockSendCoinExpectation{}
	}

	if mmSendCoin.defaultExpectation.params != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Expect")
	}

	if mmSendCoin.defaultExpectation.paramPtrs == nil {
		mmSendCoin.defaultExpectation.paramPtrs = &RepositoryMockSendCoinParamPtrs{}
	}
	mmSendCoin.defaultExpectation.paramPtrs.amount = &amount
	mmSendCoin.defaultExpectation.expectationOrigins.originAmount = minimock.CallerInfo(1)

	return mmSendCoin
}

// Inspect accepts an inspector function that has same arguments as the Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) Inspect(f func(ctx context.Context, toUserID int, fromUserID int, amount int)) *mRepositoryMockSendCoin {
	if mmSendCoin.mock.inspectFuncSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SendCoin")
	}

	mmSendCoin.mock.inspectFuncSendCoin = f

	return mmSendCoin
}

// Return sets up results that will be returned by Repository.SendCoin
func (mmSendCoin *mRepositoryMockSendCoin) Return(err error) *RepositoryMock {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	if mmSendCoin.defaultExpectation == nil {
		mmSendCoin.defaultExpectation = &RepositoryMockSendCoinExpectation{mock: mmSendCoin.mock}
	}
	mmSendCoin.defaultExpectation.results = &RepositoryMockSendCoinResults{err}
	mmSendCoin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendCoin.mock
}

// Set uses given function f to mock the Repository.SendCoin method
func (mmSendCoin *mRepositoryMockSendCoin) Set(f func(ctx context.Context, toUserID int, fromUserID int, amount int) (err error)) *RepositoryMock {
	if mmSendCoin.defaultExpectation != nil {
		mmSendCoin.mock.t.Fatalf("Default expectation is already set for the Repository.SendCoin method")
	}

	if len(mmSendCoin.expectations) > 0 {
		mmSendCoin.mock.t.Fatalf("Some expectations are already set for the Repository.SendCoin method")
	}

	mmSendCoin.mock.funcSendCoin = f
	mmSendCoin.mock.funcSendCoinOrigin = minimock.CallerInfo(1)
	return mmSendCoin.mock
}

// When sets expectation for the Repository.SendCoin which will trigger the result defined by the following
// Then helper
func (mmSendCoin *mRepositoryMockSendCoin) When(ctx context.Context, toUserID int, fromUserID int, amount int) *RepositoryMockSendCoinExpectation {
	if mmSendCoin.mock.funcSendCoin != nil {
		mmSendCoin.mock.t.Fatalf("RepositoryMock.SendCoin mock is already set by Set")
	}

	expectation := &RepositoryMockSendCoinExpectation{
		mock:               mmSendCoin.mock,
		params:             &RepositoryMockSendCoinParams{ctx, toUserID, fromUserID, amount},
		expectationOrigins: RepositoryMockSendCoinExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendCoin.expectations = append(mmSendCoin.expectations, expectation)
	return expectation
}

// Then sets up Repository.SendCoin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSendCoinExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockSendCoinResults{err}
	return e.mock
}

// Times sets number of times Repository.SendCoin should be invoked
func (mmSendCoin *mRepositoryMockSendCoin) Times(n uint64) *mRepositoryMockSendCoin {
	if n == 0 {
		mmSendCoin.mock.t.Fatalf("Times of RepositoryMock.SendCoin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendCoin.expectedInvocations, n)
	mmSendCoin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendCoin
}

func (mmSendCoin *mRepositoryMockSendCoin) invocationsDone() bool {
	if len(mmSendCoin.expectations) == 0 && mmSendCoin.defaultExpectation == nil && mmSendCoin.mock.funcSendCoin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendCoin.mock.afterSendCoinCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendCoin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendCoin implements mm_repository.Repository
func (mmSendCoin *RepositoryMock) SendCoin(ctx context.Context, toUserID int, fromUserID int, amount int) (err error) {
	mm_atomic.AddUint64(&mmSendCoin.beforeSendCoinCounter, 1)
	defer mm_atomic.AddUint64(&mmSendCoin.afterSendCoinCounter, 1)

	mmSendCoin.t.Helper()

	if mmSendCoin.inspectFuncSendCoin != nil {
		mmSendCoin.inspectFuncSendCoin(ctx, toUserID, fromUserID, amount)
	}

	mm_params := RepositoryMockSendCoinParams{ctx, toUserID, fromUserID, amount}

	// Record call args
	mmSendCoin.SendCoinMock.mutex.Lock()
	mmSendCoin.SendCoinMock.callArgs = append(mmSendCoin.SendCoinMock.callArgs, &mm_params)
	mmSendCoin.SendCoinMock.mutex.Unlock()

	for _, e := range mmSendCoin.SendCoinMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendCoin.SendCoinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendCoin.SendCoinMock.defaultExpectation.Counter, 1)
		mm_want := mmSendCoin.SendCoinMock.defaultExpectation.params
		mm_want_ptrs := mmSendCoin.SendCoinMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSendCoinParams{ctx, toUserID, fromUserID, amount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendCoin.t.Errorf("RepositoryMock.SendCoin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.toUserID != nil && !minimock.Equal(*mm_want_ptrs.toUserID, mm_got.toUserID) {
				mmSendCoin.t.Errorf("RepositoryMock.SendCoin got unexpected parameter toUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originToUserID, *mm_want_ptrs.toUserID, mm_got.toUserID, minimock.Diff(*mm_want_ptrs.toUserID, mm_got.toUserID))
			}

			if mm_want_ptrs.fromUserID != nil && !minimock.Equal(*mm_want_ptrs.fromUserID, mm_got.fromUserID) {
				mmSendCoin.t.Errorf("RepositoryMock.SendCoin got unexpected parameter fromUserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originFromUserID, *mm_want_ptrs.fromUserID, mm_got.fromUserID, minimock.Diff(*mm_want_ptrs.fromUserID, mm_got.fromUserID))
			}

			if mm_want_ptrs.amount != nil && !minimock.Equal(*mm_want_ptrs.amount, mm_got.amount) {
				mmSendCoin.t.Errorf("RepositoryMock.SendCoin got unexpected parameter amount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.originAmount, *mm_want_ptrs.amount, mm_got.amount, minimock.Diff(*mm_want_ptrs.amount, mm_got.amount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendCoin.t.Errorf("RepositoryMock.SendCoin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendCoin.SendCoinMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendCoin.SendCoinMock.defaultExpectation.results
		if mm_results == nil {
			mmSendCoin.t.Fatal("No results are set for the RepositoryMock.SendCoin")
		}
		return (*mm_results).err
	}
	if mmSendCoin.funcSendCoin != nil {
		return mmSendCoin.funcSendCoin(ctx, toUserID, fromUserID, amount)
	}
	mmSendCoin.t.Fatalf("Unexpected call to RepositoryMock.SendCoin. %v %v %v %v", ctx, toUserID, fromUserID, amount)
	return
}

// SendCoinAfterCounter returns a count of finished RepositoryMock.SendCoin invocations
func (mmSendCoin *RepositoryMock) SendCoinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCoin.afterSendCoinCounter)
}

// SendCoinBeforeCounter returns a count of RepositoryMock.SendCoin invocations
func (mmSendCoin *RepositoryMock) SendCoinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendCoin.beforeSendCoinCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SendCoin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendCoin *mRepositoryMockSendCoin) Calls() []*RepositoryMockSendCoinParams {
	mmSendCoin.mutex.RLock()

	argCopy := make([]*RepositoryMockSendCoinParams, len(mmSendCoin.callArgs))
	copy(argCopy, mmSendCoin.callArgs)

	mmSendCoin.mutex.RUnlock()

	return argCopy
}

// MinimockSendCoinDone returns true if the count of the SendCoin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSendCoinDone() bool {
	if m.SendCoinMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendCoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendCoinMock.invocationsDone()
}

// MinimockSendCoinInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSendCoinInspect() {
	for _, e := range m.SendCoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SendCoin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCoinCounter := mm_atomic.LoadUint64(&m.afterSendCoinCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendCoinMock.defaultExpectation != nil && afterSendCoinCounter < 1 {
		if m.SendCoinMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SendCoin at\n%s", m.SendCoinMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SendCoin at\n%s with params: %#v", m.SendCoinMock.defaultExpectation.expectationOrigins.origin, *m.SendCoinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendCoin != nil && afterSendCoinCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SendCoin at\n%s", m.funcSendCoinOrigin)
	}

	if !m.SendCoinMock.invocationsDone() && afterSendCoinCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SendCoin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendCoinMock.expectedInvocations), m.SendCoinMock.expectedInvocationsOrigin, afterSendCoinCounter)
	}
}

type mRepositoryMockUserByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserByIDExpectation
	expectations       []*RepositoryMockUserByIDExpectation

	callArgs []*RepositoryMockUserByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserByIDExpectation specifies expectation struct of the Repository.UserByID
type RepositoryMockUserByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserByIDParams
	paramPtrs          *RepositoryMockUserByIDParamPtrs
	expectationOrigins RepositoryMockUserByIDExpectationOrigins
	results            *RepositoryMockUserByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserByIDParams contains parameters of the Repository.UserByID
type RepositoryMockUserByIDParams struct {
	ctx    context.Context
	userID int
}

// RepositoryMockUserByIDParamPtrs contains pointers to parameters of the Repository.UserByID
type RepositoryMockUserByIDParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// RepositoryMockUserByIDResults contains results of the Repository.UserByID
type RepositoryMockUserByIDResults struct {
	up1 *rm.User
	err error
}

// RepositoryMockUserByIDOrigins contains origins of expectations of the Repository.UserByID
type RepositoryMockUserByIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserByID *mRepositoryMockUserByID) Optional() *mRepositoryMockUserByID {
	mmUserByID.optional = true
	return mmUserByID
}

// Expect sets up expected params for Repository.UserByID
func (mmUserByID *mRepositoryMockUserByID) Expect(ctx context.Context, userID int) *mRepositoryMockUserByID {
	if mmUserByID.mock.funcUserByID != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Set")
	}

	if mmUserByID.defaultExpectation == nil {
		mmUserByID.defaultExpectation = &RepositoryMockUserByIDExpectation{}
	}

	if mmUserByID.defaultExpectation.paramPtrs != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by ExpectParams functions")
	}

	mmUserByID.defaultExpectation.params = &RepositoryMockUserByIDParams{ctx, userID}
	mmUserByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserByID.expectations {
		if minimock.Equal(e.params, mmUserByID.defaultExpectation.params) {
			mmUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserByID.defaultExpectation.params)
		}
	}

	return mmUserByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserByID
func (mmUserByID *mRepositoryMockUserByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserByID {
	if mmUserByID.mock.funcUserByID != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Set")
	}

	if mmUserByID.defaultExpectation == nil {
		mmUserByID.defaultExpectation = &RepositoryMockUserByIDExpectation{}
	}

	if mmUserByID.defaultExpectation.params != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Expect")
	}

	if mmUserByID.defaultExpectation.paramPtrs == nil {
		mmUserByID.defaultExpectation.paramPtrs = &RepositoryMockUserByIDParamPtrs{}
	}
	mmUserByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserByID
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UserByID
func (mmUserByID *mRepositoryMockUserByID) ExpectUserIDParam2(userID int) *mRepositoryMockUserByID {
	if mmUserByID.mock.funcUserByID != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Set")
	}

	if mmUserByID.defaultExpectation == nil {
		mmUserByID.defaultExpectation = &RepositoryMockUserByIDExpectation{}
	}

	if mmUserByID.defaultExpectation.params != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Expect")
	}

	if mmUserByID.defaultExpectation.paramPtrs == nil {
		mmUserByID.defaultExpectation.paramPtrs = &RepositoryMockUserByIDParamPtrs{}
	}
	mmUserByID.defaultExpectation.paramPtrs.userID = &userID
	mmUserByID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserByID
func (mmUserByID *mRepositoryMockUserByID) Inspect(f func(ctx context.Context, userID int)) *mRepositoryMockUserByID {
	if mmUserByID.mock.inspectFuncUserByID != nil {
		mmUserByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserByID")
	}

	mmUserByID.mock.inspectFuncUserByID = f

	return mmUserByID
}

// Return sets up results that will be returned by Repository.UserByID
func (mmUserByID *mRepositoryMockUserByID) Return(up1 *rm.User, err error) *RepositoryMock {
	if mmUserByID.mock.funcUserByID != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Set")
	}

	if mmUserByID.defaultExpectation == nil {
		mmUserByID.defaultExpectation = &RepositoryMockUserByIDExpectation{mock: mmUserByID.mock}
	}
	mmUserByID.defaultExpectation.results = &RepositoryMockUserByIDResults{up1, err}
	mmUserByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserByID.mock
}

// Set uses given function f to mock the Repository.UserByID method
func (mmUserByID *mRepositoryMockUserByID) Set(f func(ctx context.Context, userID int) (up1 *rm.User, err error)) *RepositoryMock {
	if mmUserByID.defaultExpectation != nil {
		mmUserByID.mock.t.Fatalf("Default expectation is already set for the Repository.UserByID method")
	}

	if len(mmUserByID.expectations) > 0 {
		mmUserByID.mock.t.Fatalf("Some expectations are already set for the Repository.UserByID method")
	}

	mmUserByID.mock.funcUserByID = f
	mmUserByID.mock.funcUserByIDOrigin = minimock.CallerInfo(1)
	return mmUserByID.mock
}

// When sets expectation for the Repository.UserByID which will trigger the result defined by the following
// Then helper
func (mmUserByID *mRepositoryMockUserByID) When(ctx context.Context, userID int) *RepositoryMockUserByIDExpectation {
	if mmUserByID.mock.funcUserByID != nil {
		mmUserByID.mock.t.Fatalf("RepositoryMock.UserByID mock is already set by Set")
	}

	expectation := &RepositoryMockUserByIDExpectation{
		mock:               mmUserByID.mock,
		params:             &RepositoryMockUserByIDParams{ctx, userID},
		expectationOrigins: RepositoryMockUserByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserByID.expectations = append(mmUserByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserByIDExpectation) Then(up1 *rm.User, err error) *RepositoryMock {
	e.results = &RepositoryMockUserByIDResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.UserByID should be invoked
func (mmUserByID *mRepositoryMockUserByID) Times(n uint64) *mRepositoryMockUserByID {
	if n == 0 {
		mmUserByID.mock.t.Fatalf("Times of RepositoryMock.UserByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserByID.expectedInvocations, n)
	mmUserByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserByID
}

func (mmUserByID *mRepositoryMockUserByID) invocationsDone() bool {
	if len(mmUserByID.expectations) == 0 && mmUserByID.defaultExpectation == nil && mmUserByID.mock.funcUserByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserByID.mock.afterUserByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserByID implements mm_repository.Repository
func (mmUserByID *RepositoryMock) UserByID(ctx context.Context, userID int) (up1 *rm.User, err error) {
	mm_atomic.AddUint64(&mmUserByID.beforeUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUserByID.afterUserByIDCounter, 1)

	mmUserByID.t.Helper()

	if mmUserByID.inspectFuncUserByID != nil {
		mmUserByID.inspectFuncUserByID(ctx, userID)
	}

	mm_params := RepositoryMockUserByIDParams{ctx, userID}

	// Record call args
	mmUserByID.UserByIDMock.mutex.Lock()
	mmUserByID.UserByIDMock.callArgs = append(mmUserByID.UserByIDMock.callArgs, &mm_params)
	mmUserByID.UserByIDMock.mutex.Unlock()

	for _, e := range mmUserByID.UserByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUserByID.UserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserByID.UserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUserByID.UserByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUserByID.UserByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserByIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserByID.t.Errorf("RepositoryMock.UserByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserByID.UserByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserByID.t.Errorf("RepositoryMock.UserByID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserByID.UserByIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserByID.t.Errorf("RepositoryMock.UserByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserByID.UserByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserByID.UserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUserByID.t.Fatal("No results are set for the RepositoryMock.UserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUserByID.funcUserByID != nil {
		return mmUserByID.funcUserByID(ctx, userID)
	}
	mmUserByID.t.Fatalf("Unexpected call to RepositoryMock.UserByID. %v %v", ctx, userID)
	return
}

// UserByIDAfterCounter returns a count of finished RepositoryMock.UserByID invocations
func (mmUserByID *RepositoryMock) UserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserByID.afterUserByIDCounter)
}

// UserByIDBeforeCounter returns a count of RepositoryMock.UserByID invocations
func (mmUserByID *RepositoryMock) UserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserByID.beforeUserByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserByID *mRepositoryMockUserByID) Calls() []*RepositoryMockUserByIDParams {
	mmUserByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUserByIDParams, len(mmUserByID.callArgs))
	copy(argCopy, mmUserByID.callArgs)

	mmUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockUserByIDDone returns true if the count of the UserByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserByIDDone() bool {
	if m.UserByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserByIDMock.invocationsDone()
}

// MinimockUserByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserByIDInspect() {
	for _, e := range m.UserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserByIDCounter := mm_atomic.LoadUint64(&m.afterUserByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserByIDMock.defaultExpectation != nil && afterUserByIDCounter < 1 {
		if m.UserByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserByID at\n%s", m.UserByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserByID at\n%s with params: %#v", m.UserByIDMock.defaultExpectation.expectationOrigins.origin, *m.UserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserByID != nil && afterUserByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserByID at\n%s", m.funcUserByIDOrigin)
	}

	if !m.UserByIDMock.invocationsDone() && afterUserByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserByIDMock.expectedInvocations), m.UserByIDMock.expectedInvocationsOrigin, afterUserByIDCounter)
	}
}

type mRepositoryMockUserByUsername struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserByUsernameExpectation
	expectations       []*RepositoryMockUserByUsernameExpectation

	callArgs []*RepositoryMockUserByUsernameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserByUsernameExpectation specifies expectation struct of the Repository.UserByUsername
type RepositoryMockUserByUsernameExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserByUsernameParams
	paramPtrs          *RepositoryMockUserByUsernameParamPtrs
	expectationOrigins RepositoryMockUserByUsernameExpectationOrigins
	results            *RepositoryMockUserByUsernameResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserByUsernameParams contains parameters of the Repository.UserByUsername
type RepositoryMockUserByUsernameParams struct {
	ctx      context.Context
	username string
}

// RepositoryMockUserByUsernameParamPtrs contains pointers to parameters of the Repository.UserByUsername
type RepositoryMockUserByUsernameParamPtrs struct {
	ctx      *context.Context
	username *string
}

// RepositoryMockUserByUsernameResults contains results of the Repository.UserByUsername
type RepositoryMockUserByUsernameResults struct {
	up1 *rm.User
	err error
}

// RepositoryMockUserByUsernameOrigins contains origins of expectations of the Repository.UserByUsername
type RepositoryMockUserByUsernameExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserByUsername *mRepositoryMockUserByUsername) Optional() *mRepositoryMockUserByUsername {
	mmUserByUsername.optional = true
	return mmUserByUsername
}

// Expect sets up expected params for Repository.UserByUsername
func (mmUserByUsername *mRepositoryMockUserByUsername) Expect(ctx context.Context, username string) *mRepositoryMockUserByUsername {
	if mmUserByUsername.mock.funcUserByUsername != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Set")
	}

	if mmUserByUsername.defaultExpectation == nil {
		mmUserByUsername.defaultExpectation = &RepositoryMockUserByUsernameExpectation{}
	}

	if mmUserByUsername.defaultExpectation.paramPtrs != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by ExpectParams functions")
	}

	mmUserByUsername.defaultExpectation.params = &RepositoryMockUserByUsernameParams{ctx, username}
	mmUserByUsername.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserByUsername.expectations {
		if minimock.Equal(e.params, mmUserByUsername.defaultExpectation.params) {
			mmUserByUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserByUsername.defaultExpectation.params)
		}
	}

	return mmUserByUsername
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserByUsername
func (mmUserByUsername *mRepositoryMockUserByUsername) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserByUsername {
	if mmUserByUsername.mock.funcUserByUsername != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Set")
	}

	if mmUserByUsername.defaultExpectation == nil {
		mmUserByUsername.defaultExpectation = &RepositoryMockUserByUsernameExpectation{}
	}

	if mmUserByUsername.defaultExpectation.params != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Expect")
	}

	if mmUserByUsername.defaultExpectation.paramPtrs == nil {
		mmUserByUsername.defaultExpectation.paramPtrs = &RepositoryMockUserByUsernameParamPtrs{}
	}
	mmUserByUsername.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserByUsername.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserByUsername
}

// ExpectUsernameParam2 sets up expected param username for Repository.UserByUsername
func (mmUserByUsername *mRepositoryMockUserByUsername) ExpectUsernameParam2(username string) *mRepositoryMockUserByUsername {
	if mmUserByUsername.mock.funcUserByUsername != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Set")
	}

	if mmUserByUsername.defaultExpectation == nil {
		mmUserByUsername.defaultExpectation = &RepositoryMockUserByUsernameExpectation{}
	}

	if mmUserByUsername.defaultExpectation.params != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Expect")
	}

	if mmUserByUsername.defaultExpectation.paramPtrs == nil {
		mmUserByUsername.defaultExpectation.paramPtrs = &RepositoryMockUserByUsernameParamPtrs{}
	}
	mmUserByUsername.defaultExpectation.paramPtrs.username = &username
	mmUserByUsername.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmUserByUsername
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserByUsername
func (mmUserByUsername *mRepositoryMockUserByUsername) Inspect(f func(ctx context.Context, username string)) *mRepositoryMockUserByUsername {
	if mmUserByUsername.mock.inspectFuncUserByUsername != nil {
		mmUserByUsername.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserByUsername")
	}

	mmUserByUsername.mock.inspectFuncUserByUsername = f

	return mmUserByUsername
}

// Return sets up results that will be returned by Repository.UserByUsername
func (mmUserByUsername *mRepositoryMockUserByUsername) Return(up1 *rm.User, err error) *RepositoryMock {
	if mmUserByUsername.mock.funcUserByUsername != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Set")
	}

	if mmUserByUsername.defaultExpectation == nil {
		mmUserByUsername.defaultExpectation = &RepositoryMockUserByUsernameExpectation{mock: mmUserByUsername.mock}
	}
	mmUserByUsername.defaultExpectation.results = &RepositoryMockUserByUsernameResults{up1, err}
	mmUserByUsername.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserByUsername.mock
}

// Set uses given function f to mock the Repository.UserByUsername method
func (mmUserByUsername *mRepositoryMockUserByUsername) Set(f func(ctx context.Context, username string) (up1 *rm.User, err error)) *RepositoryMock {
	if mmUserByUsername.defaultExpectation != nil {
		mmUserByUsername.mock.t.Fatalf("Default expectation is already set for the Repository.UserByUsername method")
	}

	if len(mmUserByUsername.expectations) > 0 {
		mmUserByUsername.mock.t.Fatalf("Some expectations are already set for the Repository.UserByUsername method")
	}

	mmUserByUsername.mock.funcUserByUsername = f
	mmUserByUsername.mock.funcUserByUsernameOrigin = minimock.CallerInfo(1)
	return mmUserByUsername.mock
}

// When sets expectation for the Repository.UserByUsername which will trigger the result defined by the following
// Then helper
func (mmUserByUsername *mRepositoryMockUserByUsername) When(ctx context.Context, username string) *RepositoryMockUserByUsernameExpectation {
	if mmUserByUsername.mock.funcUserByUsername != nil {
		mmUserByUsername.mock.t.Fatalf("RepositoryMock.UserByUsername mock is already set by Set")
	}

	expectation := &RepositoryMockUserByUsernameExpectation{
		mock:               mmUserByUsername.mock,
		params:             &RepositoryMockUserByUsernameParams{ctx, username},
		expectationOrigins: RepositoryMockUserByUsernameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserByUsername.expectations = append(mmUserByUsername.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserByUsername return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserByUsernameExpectation) Then(up1 *rm.User, err error) *RepositoryMock {
	e.results = &RepositoryMockUserByUsernameResults{up1, err}
	return e.mock
}

// Times sets number of times Repository.UserByUsername should be invoked
func (mmUserByUsername *mRepositoryMockUserByUsername) Times(n uint64) *mRepositoryMockUserByUsername {
	if n == 0 {
		mmUserByUsername.mock.t.Fatalf("Times of RepositoryMock.UserByUsername mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserByUsername.expectedInvocations, n)
	mmUserByUsername.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserByUsername
}

func (mmUserByUsername *mRepositoryMockUserByUsername) invocationsDone() bool {
	if len(mmUserByUsername.expectations) == 0 && mmUserByUsername.defaultExpectation == nil && mmUserByUsername.mock.funcUserByUsername == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserByUsername.mock.afterUserByUsernameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserByUsername.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserByUsername implements mm_repository.Repository
func (mmUserByUsername *RepositoryMock) UserByUsername(ctx context.Context, username string) (up1 *rm.User, err error) {
	mm_atomic.AddUint64(&mmUserByUsername.beforeUserByUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmUserByUsername.afterUserByUsernameCounter, 1)

	mmUserByUsername.t.Helper()

	if mmUserByUsername.inspectFuncUserByUsername != nil {
		mmUserByUsername.inspectFuncUserByUsername(ctx, username)
	}

	mm_params := RepositoryMockUserByUsernameParams{ctx, username}

	// Record call args
	mmUserByUsername.UserByUsernameMock.mutex.Lock()
	mmUserByUsername.UserByUsernameMock.callArgs = append(mmUserByUsername.UserByUsernameMock.callArgs, &mm_params)
	mmUserByUsername.UserByUsernameMock.mutex.Unlock()

	for _, e := range mmUserByUsername.UserByUsernameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUserByUsername.UserByUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserByUsername.UserByUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmUserByUsername.UserByUsernameMock.defaultExpectation.params
		mm_want_ptrs := mmUserByUsername.UserByUsernameMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserByUsernameParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserByUsername.t.Errorf("RepositoryMock.UserByUsername got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserByUsername.UserByUsernameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmUserByUsername.t.Errorf("RepositoryMock.UserByUsername got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserByUsername.UserByUsernameMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserByUsername.t.Errorf("RepositoryMock.UserByUsername got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserByUsername.UserByUsernameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserByUsername.UserByUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmUserByUsername.t.Fatal("No results are set for the RepositoryMock.UserByUsername")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUserByUsername.funcUserByUsername != nil {
		return mmUserByUsername.funcUserByUsername(ctx, username)
	}
	mmUserByUsername.t.Fatalf("Unexpected call to RepositoryMock.UserByUsername. %v %v", ctx, username)
	return
}

// UserByUsernameAfterCounter returns a count of finished RepositoryMock.UserByUsername invocations
func (mmUserByUsername *RepositoryMock) UserByUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserByUsername.afterUserByUsernameCounter)
}

// UserByUsernameBeforeCounter returns a count of RepositoryMock.UserByUsername invocations
func (mmUserByUsername *RepositoryMock) UserByUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserByUsername.beforeUserByUsernameCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserByUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserByUsername *mRepositoryMockUserByUsername) Calls() []*RepositoryMockUserByUsernameParams {
	mmUserByUsername.mutex.RLock()

	argCopy := make([]*RepositoryMockUserByUsernameParams, len(mmUserByUsername.callArgs))
	copy(argCopy, mmUserByUsername.callArgs)

	mmUserByUsername.mutex.RUnlock()

	return argCopy
}

// MinimockUserByUsernameDone returns true if the count of the UserByUsername invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserByUsernameDone() bool {
	if m.UserByUsernameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserByUsernameMock.invocationsDone()
}

// MinimockUserByUsernameInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserByUsernameInspect() {
	for _, e := range m.UserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserByUsername at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserByUsernameCounter := mm_atomic.LoadUint64(&m.afterUserByUsernameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserByUsernameMock.defaultExpectation != nil && afterUserByUsernameCounter < 1 {
		if m.UserByUsernameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserByUsername at\n%s", m.UserByUsernameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserByUsername at\n%s with params: %#v", m.UserByUsernameMock.defaultExpectation.expectationOrigins.origin, *m.UserByUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserByUsername != nil && afterUserByUsernameCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserByUsername at\n%s", m.funcUserByUsernameOrigin)
	}

	if !m.UserByUsernameMock.invocationsDone() && afterUserByUsernameCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserByUsername at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserByUsernameMock.expectedInvocations), m.UserByUsernameMock.expectedInvocationsOrigin, afterUserByUsernameCounter)
	}
}

type mRepositoryMockUserIncomingTransactions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserIncomingTransactionsExpectation
	expectations       []*RepositoryMockUserIncomingTransactionsExpectation

	callArgs []*RepositoryMockUserIncomingTransactionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserIncomingTransactionsExpectation specifies expectation struct of the Repository.UserIncomingTransactions
type RepositoryMockUserIncomingTransactionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserIncomingTransactionsParams
	paramPtrs          *RepositoryMockUserIncomingTransactionsParamPtrs
	expectationOrigins RepositoryMockUserIncomingTransactionsExpectationOrigins
	results            *RepositoryMockUserIncomingTransactionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserIncomingTransactionsParams contains parameters of the Repository.UserIncomingTransactions
type RepositoryMockUserIncomingTransactionsParams struct {
	ctx    context.Context
	userID int
}

// RepositoryMockUserIncomingTransactionsParamPtrs contains pointers to parameters of the Repository.UserIncomingTransactions
type RepositoryMockUserIncomingTransactionsParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// RepositoryMockUserIncomingTransactionsResults contains results of the Repository.UserIncomingTransactions
type RepositoryMockUserIncomingTransactionsResults struct {
	tpa1 []*rm.Transaction
	err  error
}

// RepositoryMockUserIncomingTransactionsOrigins contains origins of expectations of the Repository.UserIncomingTransactions
type RepositoryMockUserIncomingTransactionsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Optional() *mRepositoryMockUserIncomingTransactions {
	mmUserIncomingTransactions.optional = true
	return mmUserIncomingTransactions
}

// Expect sets up expected params for Repository.UserIncomingTransactions
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Expect(ctx context.Context, userID int) *mRepositoryMockUserIncomingTransactions {
	if mmUserIncomingTransactions.mock.funcUserIncomingTransactions != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Set")
	}

	if mmUserIncomingTransactions.defaultExpectation == nil {
		mmUserIncomingTransactions.defaultExpectation = &RepositoryMockUserIncomingTransactionsExpectation{}
	}

	if mmUserIncomingTransactions.defaultExpectation.paramPtrs != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by ExpectParams functions")
	}

	mmUserIncomingTransactions.defaultExpectation.params = &RepositoryMockUserIncomingTransactionsParams{ctx, userID}
	mmUserIncomingTransactions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserIncomingTransactions.expectations {
		if minimock.Equal(e.params, mmUserIncomingTransactions.defaultExpectation.params) {
			mmUserIncomingTransactions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserIncomingTransactions.defaultExpectation.params)
		}
	}

	return mmUserIncomingTransactions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserIncomingTransactions
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserIncomingTransactions {
	if mmUserIncomingTransactions.mock.funcUserIncomingTransactions != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Set")
	}

	if mmUserIncomingTransactions.defaultExpectation == nil {
		mmUserIncomingTransactions.defaultExpectation = &RepositoryMockUserIncomingTransactionsExpectation{}
	}

	if mmUserIncomingTransactions.defaultExpectation.params != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Expect")
	}

	if mmUserIncomingTransactions.defaultExpectation.paramPtrs == nil {
		mmUserIncomingTransactions.defaultExpectation.paramPtrs = &RepositoryMockUserIncomingTransactionsParamPtrs{}
	}
	mmUserIncomingTransactions.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserIncomingTransactions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserIncomingTransactions
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UserIncomingTransactions
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) ExpectUserIDParam2(userID int) *mRepositoryMockUserIncomingTransactions {
	if mmUserIncomingTransactions.mock.funcUserIncomingTransactions != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Set")
	}

	if mmUserIncomingTransactions.defaultExpectation == nil {
		mmUserIncomingTransactions.defaultExpectation = &RepositoryMockUserIncomingTransactionsExpectation{}
	}

	if mmUserIncomingTransactions.defaultExpectation.params != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Expect")
	}

	if mmUserIncomingTransactions.defaultExpectation.paramPtrs == nil {
		mmUserIncomingTransactions.defaultExpectation.paramPtrs = &RepositoryMockUserIncomingTransactionsParamPtrs{}
	}
	mmUserIncomingTransactions.defaultExpectation.paramPtrs.userID = &userID
	mmUserIncomingTransactions.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserIncomingTransactions
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserIncomingTransactions
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Inspect(f func(ctx context.Context, userID int)) *mRepositoryMockUserIncomingTransactions {
	if mmUserIncomingTransactions.mock.inspectFuncUserIncomingTransactions != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserIncomingTransactions")
	}

	mmUserIncomingTransactions.mock.inspectFuncUserIncomingTransactions = f

	return mmUserIncomingTransactions
}

// Return sets up results that will be returned by Repository.UserIncomingTransactions
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Return(tpa1 []*rm.Transaction, err error) *RepositoryMock {
	if mmUserIncomingTransactions.mock.funcUserIncomingTransactions != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Set")
	}

	if mmUserIncomingTransactions.defaultExpectation == nil {
		mmUserIncomingTransactions.defaultExpectation = &RepositoryMockUserIncomingTransactionsExpectation{mock: mmUserIncomingTransactions.mock}
	}
	mmUserIncomingTransactions.defaultExpectation.results = &RepositoryMockUserIncomingTransactionsResults{tpa1, err}
	mmUserIncomingTransactions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserIncomingTransactions.mock
}

// Set uses given function f to mock the Repository.UserIncomingTransactions method
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Set(f func(ctx context.Context, userID int) (tpa1 []*rm.Transaction, err error)) *RepositoryMock {
	if mmUserIncomingTransactions.defaultExpectation != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("Default expectation is already set for the Repository.UserIncomingTransactions method")
	}

	if len(mmUserIncomingTransactions.expectations) > 0 {
		mmUserIncomingTransactions.mock.t.Fatalf("Some expectations are already set for the Repository.UserIncomingTransactions method")
	}

	mmUserIncomingTransactions.mock.funcUserIncomingTransactions = f
	mmUserIncomingTransactions.mock.funcUserIncomingTransactionsOrigin = minimock.CallerInfo(1)
	return mmUserIncomingTransactions.mock
}

// When sets expectation for the Repository.UserIncomingTransactions which will trigger the result defined by the following
// Then helper
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) When(ctx context.Context, userID int) *RepositoryMockUserIncomingTransactionsExpectation {
	if mmUserIncomingTransactions.mock.funcUserIncomingTransactions != nil {
		mmUserIncomingTransactions.mock.t.Fatalf("RepositoryMock.UserIncomingTransactions mock is already set by Set")
	}

	expectation := &RepositoryMockUserIncomingTransactionsExpectation{
		mock:               mmUserIncomingTransactions.mock,
		params:             &RepositoryMockUserIncomingTransactionsParams{ctx, userID},
		expectationOrigins: RepositoryMockUserIncomingTransactionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserIncomingTransactions.expectations = append(mmUserIncomingTransactions.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserIncomingTransactions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserIncomingTransactionsExpectation) Then(tpa1 []*rm.Transaction, err error) *RepositoryMock {
	e.results = &RepositoryMockUserIncomingTransactionsResults{tpa1, err}
	return e.mock
}

// Times sets number of times Repository.UserIncomingTransactions should be invoked
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Times(n uint64) *mRepositoryMockUserIncomingTransactions {
	if n == 0 {
		mmUserIncomingTransactions.mock.t.Fatalf("Times of RepositoryMock.UserIncomingTransactions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserIncomingTransactions.expectedInvocations, n)
	mmUserIncomingTransactions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserIncomingTransactions
}

func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) invocationsDone() bool {
	if len(mmUserIncomingTransactions.expectations) == 0 && mmUserIncomingTransactions.defaultExpectation == nil && mmUserIncomingTransactions.mock.funcUserIncomingTransactions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserIncomingTransactions.mock.afterUserIncomingTransactionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserIncomingTransactions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserIncomingTransactions implements mm_repository.Repository
func (mmUserIncomingTransactions *RepositoryMock) UserIncomingTransactions(ctx context.Context, userID int) (tpa1 []*rm.Transaction, err error) {
	mm_atomic.AddUint64(&mmUserIncomingTransactions.beforeUserIncomingTransactionsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserIncomingTransactions.afterUserIncomingTransactionsCounter, 1)

	mmUserIncomingTransactions.t.Helper()

	if mmUserIncomingTransactions.inspectFuncUserIncomingTransactions != nil {
		mmUserIncomingTransactions.inspectFuncUserIncomingTransactions(ctx, userID)
	}

	mm_params := RepositoryMockUserIncomingTransactionsParams{ctx, userID}

	// Record call args
	mmUserIncomingTransactions.UserIncomingTransactionsMock.mutex.Lock()
	mmUserIncomingTransactions.UserIncomingTransactionsMock.callArgs = append(mmUserIncomingTransactions.UserIncomingTransactionsMock.callArgs, &mm_params)
	mmUserIncomingTransactions.UserIncomingTransactionsMock.mutex.Unlock()

	for _, e := range mmUserIncomingTransactions.UserIncomingTransactionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.params
		mm_want_ptrs := mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserIncomingTransactionsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserIncomingTransactions.t.Errorf("RepositoryMock.UserIncomingTransactions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserIncomingTransactions.t.Errorf("RepositoryMock.UserIncomingTransactions got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserIncomingTransactions.t.Errorf("RepositoryMock.UserIncomingTransactions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserIncomingTransactions.UserIncomingTransactionsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserIncomingTransactions.t.Fatal("No results are set for the RepositoryMock.UserIncomingTransactions")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmUserIncomingTransactions.funcUserIncomingTransactions != nil {
		return mmUserIncomingTransactions.funcUserIncomingTransactions(ctx, userID)
	}
	mmUserIncomingTransactions.t.Fatalf("Unexpected call to RepositoryMock.UserIncomingTransactions. %v %v", ctx, userID)
	return
}

// UserIncomingTransactionsAfterCounter returns a count of finished RepositoryMock.UserIncomingTransactions invocations
func (mmUserIncomingTransactions *RepositoryMock) UserIncomingTransactionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserIncomingTransactions.afterUserIncomingTransactionsCounter)
}

// UserIncomingTransactionsBeforeCounter returns a count of RepositoryMock.UserIncomingTransactions invocations
func (mmUserIncomingTransactions *RepositoryMock) UserIncomingTransactionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserIncomingTransactions.beforeUserIncomingTransactionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserIncomingTransactions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserIncomingTransactions *mRepositoryMockUserIncomingTransactions) Calls() []*RepositoryMockUserIncomingTransactionsParams {
	mmUserIncomingTransactions.mutex.RLock()

	argCopy := make([]*RepositoryMockUserIncomingTransactionsParams, len(mmUserIncomingTransactions.callArgs))
	copy(argCopy, mmUserIncomingTransactions.callArgs)

	mmUserIncomingTransactions.mutex.RUnlock()

	return argCopy
}

// MinimockUserIncomingTransactionsDone returns true if the count of the UserIncomingTransactions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserIncomingTransactionsDone() bool {
	if m.UserIncomingTransactionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserIncomingTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserIncomingTransactionsMock.invocationsDone()
}

// MinimockUserIncomingTransactionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserIncomingTransactionsInspect() {
	for _, e := range m.UserIncomingTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserIncomingTransactions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserIncomingTransactionsCounter := mm_atomic.LoadUint64(&m.afterUserIncomingTransactionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserIncomingTransactionsMock.defaultExpectation != nil && afterUserIncomingTransactionsCounter < 1 {
		if m.UserIncomingTransactionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserIncomingTransactions at\n%s", m.UserIncomingTransactionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserIncomingTransactions at\n%s with params: %#v", m.UserIncomingTransactionsMock.defaultExpectation.expectationOrigins.origin, *m.UserIncomingTransactionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserIncomingTransactions != nil && afterUserIncomingTransactionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserIncomingTransactions at\n%s", m.funcUserIncomingTransactionsOrigin)
	}

	if !m.UserIncomingTransactionsMock.invocationsDone() && afterUserIncomingTransactionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserIncomingTransactions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserIncomingTransactionsMock.expectedInvocations), m.UserIncomingTransactionsMock.expectedInvocationsOrigin, afterUserIncomingTransactionsCounter)
	}
}

type mRepositoryMockUserInventory struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserInventoryExpectation
	expectations       []*RepositoryMockUserInventoryExpectation

	callArgs []*RepositoryMockUserInventoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserInventoryExpectation specifies expectation struct of the Repository.UserInventory
type RepositoryMockUserInventoryExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserInventoryParams
	paramPtrs          *RepositoryMockUserInventoryParamPtrs
	expectationOrigins RepositoryMockUserInventoryExpectationOrigins
	results            *RepositoryMockUserInventoryResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserInventoryParams contains parameters of the Repository.UserInventory
type RepositoryMockUserInventoryParams struct {
	ctx    context.Context
	userID int
}

// RepositoryMockUserInventoryParamPtrs contains pointers to parameters of the Repository.UserInventory
type RepositoryMockUserInventoryParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// RepositoryMockUserInventoryResults contains results of the Repository.UserInventory
type RepositoryMockUserInventoryResults struct {
	ipa1 []*rm.InventoryItem
	err  error
}

// RepositoryMockUserInventoryOrigins contains origins of expectations of the Repository.UserInventory
type RepositoryMockUserInventoryExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserInventory *mRepositoryMockUserInventory) Optional() *mRepositoryMockUserInventory {
	mmUserInventory.optional = true
	return mmUserInventory
}

// Expect sets up expected params for Repository.UserInventory
func (mmUserInventory *mRepositoryMockUserInventory) Expect(ctx context.Context, userID int) *mRepositoryMockUserInventory {
	if mmUserInventory.mock.funcUserInventory != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Set")
	}

	if mmUserInventory.defaultExpectation == nil {
		mmUserInventory.defaultExpectation = &RepositoryMockUserInventoryExpectation{}
	}

	if mmUserInventory.defaultExpectation.paramPtrs != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by ExpectParams functions")
	}

	mmUserInventory.defaultExpectation.params = &RepositoryMockUserInventoryParams{ctx, userID}
	mmUserInventory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserInventory.expectations {
		if minimock.Equal(e.params, mmUserInventory.defaultExpectation.params) {
			mmUserInventory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserInventory.defaultExpectation.params)
		}
	}

	return mmUserInventory
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserInventory
func (mmUserInventory *mRepositoryMockUserInventory) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserInventory {
	if mmUserInventory.mock.funcUserInventory != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Set")
	}

	if mmUserInventory.defaultExpectation == nil {
		mmUserInventory.defaultExpectation = &RepositoryMockUserInventoryExpectation{}
	}

	if mmUserInventory.defaultExpectation.params != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Expect")
	}

	if mmUserInventory.defaultExpectation.paramPtrs == nil {
		mmUserInventory.defaultExpectation.paramPtrs = &RepositoryMockUserInventoryParamPtrs{}
	}
	mmUserInventory.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserInventory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserInventory
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UserInventory
func (mmUserInventory *mRepositoryMockUserInventory) ExpectUserIDParam2(userID int) *mRepositoryMockUserInventory {
	if mmUserInventory.mock.funcUserInventory != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Set")
	}

	if mmUserInventory.defaultExpectation == nil {
		mmUserInventory.defaultExpectation = &RepositoryMockUserInventoryExpectation{}
	}

	if mmUserInventory.defaultExpectation.params != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Expect")
	}

	if mmUserInventory.defaultExpectation.paramPtrs == nil {
		mmUserInventory.defaultExpectation.paramPtrs = &RepositoryMockUserInventoryParamPtrs{}
	}
	mmUserInventory.defaultExpectation.paramPtrs.userID = &userID
	mmUserInventory.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserInventory
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserInventory
func (mmUserInventory *mRepositoryMockUserInventory) Inspect(f func(ctx context.Context, userID int)) *mRepositoryMockUserInventory {
	if mmUserInventory.mock.inspectFuncUserInventory != nil {
		mmUserInventory.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserInventory")
	}

	mmUserInventory.mock.inspectFuncUserInventory = f

	return mmUserInventory
}

// Return sets up results that will be returned by Repository.UserInventory
func (mmUserInventory *mRepositoryMockUserInventory) Return(ipa1 []*rm.InventoryItem, err error) *RepositoryMock {
	if mmUserInventory.mock.funcUserInventory != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Set")
	}

	if mmUserInventory.defaultExpectation == nil {
		mmUserInventory.defaultExpectation = &RepositoryMockUserInventoryExpectation{mock: mmUserInventory.mock}
	}
	mmUserInventory.defaultExpectation.results = &RepositoryMockUserInventoryResults{ipa1, err}
	mmUserInventory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserInventory.mock
}

// Set uses given function f to mock the Repository.UserInventory method
func (mmUserInventory *mRepositoryMockUserInventory) Set(f func(ctx context.Context, userID int) (ipa1 []*rm.InventoryItem, err error)) *RepositoryMock {
	if mmUserInventory.defaultExpectation != nil {
		mmUserInventory.mock.t.Fatalf("Default expectation is already set for the Repository.UserInventory method")
	}

	if len(mmUserInventory.expectations) > 0 {
		mmUserInventory.mock.t.Fatalf("Some expectations are already set for the Repository.UserInventory method")
	}

	mmUserInventory.mock.funcUserInventory = f
	mmUserInventory.mock.funcUserInventoryOrigin = minimock.CallerInfo(1)
	return mmUserInventory.mock
}

// When sets expectation for the Repository.UserInventory which will trigger the result defined by the following
// Then helper
func (mmUserInventory *mRepositoryMockUserInventory) When(ctx context.Context, userID int) *RepositoryMockUserInventoryExpectation {
	if mmUserInventory.mock.funcUserInventory != nil {
		mmUserInventory.mock.t.Fatalf("RepositoryMock.UserInventory mock is already set by Set")
	}

	expectation := &RepositoryMockUserInventoryExpectation{
		mock:               mmUserInventory.mock,
		params:             &RepositoryMockUserInventoryParams{ctx, userID},
		expectationOrigins: RepositoryMockUserInventoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserInventory.expectations = append(mmUserInventory.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserInventory return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserInventoryExpectation) Then(ipa1 []*rm.InventoryItem, err error) *RepositoryMock {
	e.results = &RepositoryMockUserInventoryResults{ipa1, err}
	return e.mock
}

// Times sets number of times Repository.UserInventory should be invoked
func (mmUserInventory *mRepositoryMockUserInventory) Times(n uint64) *mRepositoryMockUserInventory {
	if n == 0 {
		mmUserInventory.mock.t.Fatalf("Times of RepositoryMock.UserInventory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserInventory.expectedInvocations, n)
	mmUserInventory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserInventory
}

func (mmUserInventory *mRepositoryMockUserInventory) invocationsDone() bool {
	if len(mmUserInventory.expectations) == 0 && mmUserInventory.defaultExpectation == nil && mmUserInventory.mock.funcUserInventory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserInventory.mock.afterUserInventoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserInventory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserInventory implements mm_repository.Repository
func (mmUserInventory *RepositoryMock) UserInventory(ctx context.Context, userID int) (ipa1 []*rm.InventoryItem, err error) {
	mm_atomic.AddUint64(&mmUserInventory.beforeUserInventoryCounter, 1)
	defer mm_atomic.AddUint64(&mmUserInventory.afterUserInventoryCounter, 1)

	mmUserInventory.t.Helper()

	if mmUserInventory.inspectFuncUserInventory != nil {
		mmUserInventory.inspectFuncUserInventory(ctx, userID)
	}

	mm_params := RepositoryMockUserInventoryParams{ctx, userID}

	// Record call args
	mmUserInventory.UserInventoryMock.mutex.Lock()
	mmUserInventory.UserInventoryMock.callArgs = append(mmUserInventory.UserInventoryMock.callArgs, &mm_params)
	mmUserInventory.UserInventoryMock.mutex.Unlock()

	for _, e := range mmUserInventory.UserInventoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ipa1, e.results.err
		}
	}

	if mmUserInventory.UserInventoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserInventory.UserInventoryMock.defaultExpectation.Counter, 1)
		mm_want := mmUserInventory.UserInventoryMock.defaultExpectation.params
		mm_want_ptrs := mmUserInventory.UserInventoryMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserInventoryParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserInventory.t.Errorf("RepositoryMock.UserInventory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInventory.UserInventoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserInventory.t.Errorf("RepositoryMock.UserInventory got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserInventory.UserInventoryMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserInventory.t.Errorf("RepositoryMock.UserInventory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserInventory.UserInventoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserInventory.UserInventoryMock.defaultExpectation.results
		if mm_results == nil {
			mmUserInventory.t.Fatal("No results are set for the RepositoryMock.UserInventory")
		}
		return (*mm_results).ipa1, (*mm_results).err
	}
	if mmUserInventory.funcUserInventory != nil {
		return mmUserInventory.funcUserInventory(ctx, userID)
	}
	mmUserInventory.t.Fatalf("Unexpected call to RepositoryMock.UserInventory. %v %v", ctx, userID)
	return
}

// UserInventoryAfterCounter returns a count of finished RepositoryMock.UserInventory invocations
func (mmUserInventory *RepositoryMock) UserInventoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInventory.afterUserInventoryCounter)
}

// UserInventoryBeforeCounter returns a count of RepositoryMock.UserInventory invocations
func (mmUserInventory *RepositoryMock) UserInventoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserInventory.beforeUserInventoryCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserInventory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserInventory *mRepositoryMockUserInventory) Calls() []*RepositoryMockUserInventoryParams {
	mmUserInventory.mutex.RLock()

	argCopy := make([]*RepositoryMockUserInventoryParams, len(mmUserInventory.callArgs))
	copy(argCopy, mmUserInventory.callArgs)

	mmUserInventory.mutex.RUnlock()

	return argCopy
}

// MinimockUserInventoryDone returns true if the count of the UserInventory invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserInventoryDone() bool {
	if m.UserInventoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserInventoryMock.invocationsDone()
}

// MinimockUserInventoryInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserInventoryInspect() {
	for _, e := range m.UserInventoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserInventory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserInventoryCounter := mm_atomic.LoadUint64(&m.afterUserInventoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserInventoryMock.defaultExpectation != nil && afterUserInventoryCounter < 1 {
		if m.UserInventoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserInventory at\n%s", m.UserInventoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserInventory at\n%s with params: %#v", m.UserInventoryMock.defaultExpectation.expectationOrigins.origin, *m.UserInventoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserInventory != nil && afterUserInventoryCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserInventory at\n%s", m.funcUserInventoryOrigin)
	}

	if !m.UserInventoryMock.invocationsDone() && afterUserInventoryCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserInventory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserInventoryMock.expectedInvocations), m.UserInventoryMock.expectedInvocationsOrigin, afterUserInventoryCounter)
	}
}

type mRepositoryMockUserOutgoingTransactions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUserOutgoingTransactionsExpectation
	expectations       []*RepositoryMockUserOutgoingTransactionsExpectation

	callArgs []*RepositoryMockUserOutgoingTransactionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUserOutgoingTransactionsExpectation specifies expectation struct of the Repository.UserOutgoingTransactions
type RepositoryMockUserOutgoingTransactionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUserOutgoingTransactionsParams
	paramPtrs          *RepositoryMockUserOutgoingTransactionsParamPtrs
	expectationOrigins RepositoryMockUserOutgoingTransactionsExpectationOrigins
	results            *RepositoryMockUserOutgoingTransactionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUserOutgoingTransactionsParams contains parameters of the Repository.UserOutgoingTransactions
type RepositoryMockUserOutgoingTransactionsParams struct {
	ctx    context.Context
	userID int
}

// RepositoryMockUserOutgoingTransactionsParamPtrs contains pointers to parameters of the Repository.UserOutgoingTransactions
type RepositoryMockUserOutgoingTransactionsParamPtrs struct {
	ctx    *context.Context
	userID *int
}

// RepositoryMockUserOutgoingTransactionsResults contains results of the Repository.UserOutgoingTransactions
type RepositoryMockUserOutgoingTransactionsResults struct {
	tpa1 []*rm.Transaction
	err  error
}

// RepositoryMockUserOutgoingTransactionsOrigins contains origins of expectations of the Repository.UserOutgoingTransactions
type RepositoryMockUserOutgoingTransactionsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Optional() *mRepositoryMockUserOutgoingTransactions {
	mmUserOutgoingTransactions.optional = true
	return mmUserOutgoingTransactions
}

// Expect sets up expected params for Repository.UserOutgoingTransactions
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Expect(ctx context.Context, userID int) *mRepositoryMockUserOutgoingTransactions {
	if mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Set")
	}

	if mmUserOutgoingTransactions.defaultExpectation == nil {
		mmUserOutgoingTransactions.defaultExpectation = &RepositoryMockUserOutgoingTransactionsExpectation{}
	}

	if mmUserOutgoingTransactions.defaultExpectation.paramPtrs != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by ExpectParams functions")
	}

	mmUserOutgoingTransactions.defaultExpectation.params = &RepositoryMockUserOutgoingTransactionsParams{ctx, userID}
	mmUserOutgoingTransactions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUserOutgoingTransactions.expectations {
		if minimock.Equal(e.params, mmUserOutgoingTransactions.defaultExpectation.params) {
			mmUserOutgoingTransactions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserOutgoingTransactions.defaultExpectation.params)
		}
	}

	return mmUserOutgoingTransactions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UserOutgoingTransactions
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUserOutgoingTransactions {
	if mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Set")
	}

	if mmUserOutgoingTransactions.defaultExpectation == nil {
		mmUserOutgoingTransactions.defaultExpectation = &RepositoryMockUserOutgoingTransactionsExpectation{}
	}

	if mmUserOutgoingTransactions.defaultExpectation.params != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Expect")
	}

	if mmUserOutgoingTransactions.defaultExpectation.paramPtrs == nil {
		mmUserOutgoingTransactions.defaultExpectation.paramPtrs = &RepositoryMockUserOutgoingTransactionsParamPtrs{}
	}
	mmUserOutgoingTransactions.defaultExpectation.paramPtrs.ctx = &ctx
	mmUserOutgoingTransactions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUserOutgoingTransactions
}

// ExpectUserIDParam2 sets up expected param userID for Repository.UserOutgoingTransactions
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) ExpectUserIDParam2(userID int) *mRepositoryMockUserOutgoingTransactions {
	if mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Set")
	}

	if mmUserOutgoingTransactions.defaultExpectation == nil {
		mmUserOutgoingTransactions.defaultExpectation = &RepositoryMockUserOutgoingTransactionsExpectation{}
	}

	if mmUserOutgoingTransactions.defaultExpectation.params != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Expect")
	}

	if mmUserOutgoingTransactions.defaultExpectation.paramPtrs == nil {
		mmUserOutgoingTransactions.defaultExpectation.paramPtrs = &RepositoryMockUserOutgoingTransactionsParamPtrs{}
	}
	mmUserOutgoingTransactions.defaultExpectation.paramPtrs.userID = &userID
	mmUserOutgoingTransactions.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUserOutgoingTransactions
}

// Inspect accepts an inspector function that has same arguments as the Repository.UserOutgoingTransactions
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Inspect(f func(ctx context.Context, userID int)) *mRepositoryMockUserOutgoingTransactions {
	if mmUserOutgoingTransactions.mock.inspectFuncUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UserOutgoingTransactions")
	}

	mmUserOutgoingTransactions.mock.inspectFuncUserOutgoingTransactions = f

	return mmUserOutgoingTransactions
}

// Return sets up results that will be returned by Repository.UserOutgoingTransactions
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Return(tpa1 []*rm.Transaction, err error) *RepositoryMock {
	if mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Set")
	}

	if mmUserOutgoingTransactions.defaultExpectation == nil {
		mmUserOutgoingTransactions.defaultExpectation = &RepositoryMockUserOutgoingTransactionsExpectation{mock: mmUserOutgoingTransactions.mock}
	}
	mmUserOutgoingTransactions.defaultExpectation.results = &RepositoryMockUserOutgoingTransactionsResults{tpa1, err}
	mmUserOutgoingTransactions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUserOutgoingTransactions.mock
}

// Set uses given function f to mock the Repository.UserOutgoingTransactions method
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Set(f func(ctx context.Context, userID int) (tpa1 []*rm.Transaction, err error)) *RepositoryMock {
	if mmUserOutgoingTransactions.defaultExpectation != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("Default expectation is already set for the Repository.UserOutgoingTransactions method")
	}

	if len(mmUserOutgoingTransactions.expectations) > 0 {
		mmUserOutgoingTransactions.mock.t.Fatalf("Some expectations are already set for the Repository.UserOutgoingTransactions method")
	}

	mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions = f
	mmUserOutgoingTransactions.mock.funcUserOutgoingTransactionsOrigin = minimock.CallerInfo(1)
	return mmUserOutgoingTransactions.mock
}

// When sets expectation for the Repository.UserOutgoingTransactions which will trigger the result defined by the following
// Then helper
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) When(ctx context.Context, userID int) *RepositoryMockUserOutgoingTransactionsExpectation {
	if mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.mock.t.Fatalf("RepositoryMock.UserOutgoingTransactions mock is already set by Set")
	}

	expectation := &RepositoryMockUserOutgoingTransactionsExpectation{
		mock:               mmUserOutgoingTransactions.mock,
		params:             &RepositoryMockUserOutgoingTransactionsParams{ctx, userID},
		expectationOrigins: RepositoryMockUserOutgoingTransactionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUserOutgoingTransactions.expectations = append(mmUserOutgoingTransactions.expectations, expectation)
	return expectation
}

// Then sets up Repository.UserOutgoingTransactions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUserOutgoingTransactionsExpectation) Then(tpa1 []*rm.Transaction, err error) *RepositoryMock {
	e.results = &RepositoryMockUserOutgoingTransactionsResults{tpa1, err}
	return e.mock
}

// Times sets number of times Repository.UserOutgoingTransactions should be invoked
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Times(n uint64) *mRepositoryMockUserOutgoingTransactions {
	if n == 0 {
		mmUserOutgoingTransactions.mock.t.Fatalf("Times of RepositoryMock.UserOutgoingTransactions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUserOutgoingTransactions.expectedInvocations, n)
	mmUserOutgoingTransactions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUserOutgoingTransactions
}

func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) invocationsDone() bool {
	if len(mmUserOutgoingTransactions.expectations) == 0 && mmUserOutgoingTransactions.defaultExpectation == nil && mmUserOutgoingTransactions.mock.funcUserOutgoingTransactions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUserOutgoingTransactions.mock.afterUserOutgoingTransactionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUserOutgoingTransactions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UserOutgoingTransactions implements mm_repository.Repository
func (mmUserOutgoingTransactions *RepositoryMock) UserOutgoingTransactions(ctx context.Context, userID int) (tpa1 []*rm.Transaction, err error) {
	mm_atomic.AddUint64(&mmUserOutgoingTransactions.beforeUserOutgoingTransactionsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserOutgoingTransactions.afterUserOutgoingTransactionsCounter, 1)

	mmUserOutgoingTransactions.t.Helper()

	if mmUserOutgoingTransactions.inspectFuncUserOutgoingTransactions != nil {
		mmUserOutgoingTransactions.inspectFuncUserOutgoingTransactions(ctx, userID)
	}

	mm_params := RepositoryMockUserOutgoingTransactionsParams{ctx, userID}

	// Record call args
	mmUserOutgoingTransactions.UserOutgoingTransactionsMock.mutex.Lock()
	mmUserOutgoingTransactions.UserOutgoingTransactionsMock.callArgs = append(mmUserOutgoingTransactions.UserOutgoingTransactionsMock.callArgs, &mm_params)
	mmUserOutgoingTransactions.UserOutgoingTransactionsMock.mutex.Unlock()

	for _, e := range mmUserOutgoingTransactions.UserOutgoingTransactionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tpa1, e.results.err
		}
	}

	if mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.params
		mm_want_ptrs := mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUserOutgoingTransactionsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUserOutgoingTransactions.t.Errorf("RepositoryMock.UserOutgoingTransactions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUserOutgoingTransactions.t.Errorf("RepositoryMock.UserOutgoingTransactions got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserOutgoingTransactions.t.Errorf("RepositoryMock.UserOutgoingTransactions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserOutgoingTransactions.UserOutgoingTransactionsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserOutgoingTransactions.t.Fatal("No results are set for the RepositoryMock.UserOutgoingTransactions")
		}
		return (*mm_results).tpa1, (*mm_results).err
	}
	if mmUserOutgoingTransactions.funcUserOutgoingTransactions != nil {
		return mmUserOutgoingTransactions.funcUserOutgoingTransactions(ctx, userID)
	}
	mmUserOutgoingTransactions.t.Fatalf("Unexpected call to RepositoryMock.UserOutgoingTransactions. %v %v", ctx, userID)
	return
}

// UserOutgoingTransactionsAfterCounter returns a count of finished RepositoryMock.UserOutgoingTransactions invocations
func (mmUserOutgoingTransactions *RepositoryMock) UserOutgoingTransactionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserOutgoingTransactions.afterUserOutgoingTransactionsCounter)
}

// UserOutgoingTransactionsBeforeCounter returns a count of RepositoryMock.UserOutgoingTransactions invocations
func (mmUserOutgoingTransactions *RepositoryMock) UserOutgoingTransactionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserOutgoingTransactions.beforeUserOutgoingTransactionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UserOutgoingTransactions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserOutgoingTransactions *mRepositoryMockUserOutgoingTransactions) Calls() []*RepositoryMockUserOutgoingTransactionsParams {
	mmUserOutgoingTransactions.mutex.RLock()

	argCopy := make([]*RepositoryMockUserOutgoingTransactionsParams, len(mmUserOutgoingTransactions.callArgs))
	copy(argCopy, mmUserOutgoingTransactions.callArgs)

	mmUserOutgoingTransactions.mutex.RUnlock()

	return argCopy
}

// MinimockUserOutgoingTransactionsDone returns true if the count of the UserOutgoingTransactions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUserOutgoingTransactionsDone() bool {
	if m.UserOutgoingTransactionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UserOutgoingTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UserOutgoingTransactionsMock.invocationsDone()
}

// MinimockUserOutgoingTransactionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUserOutgoingTransactionsInspect() {
	for _, e := range m.UserOutgoingTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UserOutgoingTransactions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUserOutgoingTransactionsCounter := mm_atomic.LoadUint64(&m.afterUserOutgoingTransactionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UserOutgoingTransactionsMock.defaultExpectation != nil && afterUserOutgoingTransactionsCounter < 1 {
		if m.UserOutgoingTransactionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UserOutgoingTransactions at\n%s", m.UserOutgoingTransactionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UserOutgoingTransactions at\n%s with params: %#v", m.UserOutgoingTransactionsMock.defaultExpectation.expectationOrigins.origin, *m.UserOutgoingTransactionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserOutgoingTransactions != nil && afterUserOutgoingTransactionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UserOutgoingTransactions at\n%s", m.funcUserOutgoingTransactionsOrigin)
	}

	if !m.UserOutgoingTransactionsMock.invocationsDone() && afterUserOutgoingTransactionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UserOutgoingTransactions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UserOutgoingTransactionsMock.expectedInvocations), m.UserOutgoingTransactionsMock.expectedInvocationsOrigin, afterUserOutgoingTransactionsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBuyItemInspect()

			m.MinimockInsertUserInspect()

			m.MinimockItemInspect()

			m.MinimockSendCoinInspect()

			m.MinimockUserByIDInspect()

			m.MinimockUserByUsernameInspect()

			m.MinimockUserIncomingTransactionsInspect()

			m.MinimockUserInventoryInspect()

			m.MinimockUserOutgoingTransactionsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBuyItemDone() &&
		m.MinimockInsertUserDone() &&
		m.MinimockItemDone() &&
		m.MinimockSendCoinDone() &&
		m.MinimockUserByIDDone() &&
		m.MinimockUserByUsernameDone() &&
		m.MinimockUserIncomingTransactionsDone() &&
		m.MinimockUserInventoryDone() &&
		m.MinimockUserOutgoingTransactionsDone()
}
